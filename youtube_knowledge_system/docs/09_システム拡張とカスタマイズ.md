# 第9章: システム拡張とカスタマイズ

## **章の概要**

この章では、YouTubeナレッジシステムの拡張性とカスタマイズ機能について詳しく解説します。プラグインアーキテクチャ、フックシステム、カスタム分析器、外部API連携、拡張ポイントの設計まで、柔軟で拡張可能なシステム設計技術を体系的に学びます。

**対象技術**: プラグインシステム、フックアーキテクチャ、API拡張、モジュール設計  
**主要パターン**: Strategy, Observer, Factory, Extension Point パターン

---

## **🔌 プラグインアーキテクチャの設計**

### **プラグインシステムとは（初心者向け解説）**

#### **🏗️ プラグインアーキテクチャの基本概念**

**プラグインシステムの仕組み**

プラグインアーキテクチャは、**コアシステムを変更せずに機能を追加・拡張する設計パターン**です。スマートフォンのアプリストアに例えると：

```python
# コアシステム（スマートフォンのOS）
class YouTubeKnowledgeCore:
    def __init__(self):
        self.analyzers = []        # 分析プラグイン
        self.collectors = []       # 収集プラグイン
        self.exporters = []        # エクスポートプラグイン
        self.hooks = {}           # フックシステム
    
    def register_plugin(self, plugin):
        """プラグイン登録（アプリインストール）"""
        plugin.initialize(self)

# プラグイン（アプリ）
class SentimentAnalyzerPlugin:
    def initialize(self, core):
        """コアシステムに機能追加"""
        core.analyzers.append(self)
        core.hooks.register('video_analyzed', self.on_video_analyzed)
```

**従来のモノリシック vs プラグインアーキテクチャ**

```python
# ❌ モノリシック（一体型）の問題
class MonolithicAnalyzer:
    def analyze(self, video):
        # 全機能が一箇所に集中
        sentiment = self.analyze_sentiment(video)      # 感情分析
        topics = self.extract_topics(video)           # トピック抽出
        keywords = self.extract_keywords(video)       # キーワード抽出
        # → 新機能追加時にコア修正が必要

# ✅ プラグイン型の利点
class PluginBasedAnalyzer:
    def __init__(self):
        self.plugins = []
    
    def analyze(self, video):
        results = {}
        for plugin in self.plugins:
            if plugin.can_analyze(video):
                results[plugin.name] = plugin.analyze(video)
        return results
        # → プラグイン追加でコア変更不要
```

#### **🎯 拡張ポイント（Extension Points）の設計**

```python
class ExtensionPoint:
    """拡張ポイントの基底クラス"""
    
    def __init__(self, name: str, description: str):
        self.name = name
        self.description = description
        self.extensions = []
    
    def register(self, extension):
        """拡張の登録"""
        if self.validate_extension(extension):
            self.extensions.append(extension)
            print(f"拡張登録: {extension.__class__.__name__} → {self.name}")
        else:
            raise ValueError(f"無効な拡張: {extension}")
    
    def validate_extension(self, extension) -> bool:
        """拡張の妥当性チェック"""
        # サブクラスで実装
        raise NotImplementedError
    
    def execute_all(self, *args, **kwargs):
        """全拡張の実行"""
        results = []
        for extension in self.extensions:
            try:
                result = extension.execute(*args, **kwargs)
                results.append(result)
            except Exception as e:
                print(f"拡張実行エラー {extension.__class__.__name__}: {e}")
        return results

class AnalyzerExtensionPoint(ExtensionPoint):
    """分析器拡張ポイント"""
    
    def __init__(self):
        super().__init__(
            "video_analyzer",
            "YouTube動画の分析機能を拡張"
        )
    
    def validate_extension(self, extension) -> bool:
        """分析器インターフェースの検証"""
        required_methods = ['analyze', 'get_name', 'can_handle']
        return all(hasattr(extension, method) for method in required_methods)

class CollectorExtensionPoint(ExtensionPoint):
    """データ収集拡張ポイント"""
    
    def __init__(self):
        super().__init__(
            "data_collector", 
            "データ収集機能を拡張"
        )
    
    def validate_extension(self, extension) -> bool:
        required_methods = ['collect', 'get_source_name', 'get_data_types']
        return all(hasattr(extension, method) for method in required_methods)
```

### **プラグイン発見・読み込みシステム**

#### **📦 動的プラグイン発見**

```python
import importlib
import pkgutil
from pathlib import Path
from typing import List, Type, Dict, Any
import json

class PluginManager:
    """プラグイン管理システム"""
    
    def __init__(self, plugin_directories: List[Path] = None):
        self.plugin_directories = plugin_directories or [
            Path(__file__).parent / "plugins",
            Path.home() / ".youtube_knowledge" / "plugins"
        ]
        self.extension_points = {}
        self.loaded_plugins = {}
        self.plugin_configs = {}
        
        self.setup_extension_points()
    
    def setup_extension_points(self):
        """標準拡張ポイントの設定"""
        self.extension_points = {
            'analyzers': AnalyzerExtensionPoint(),
            'collectors': CollectorExtensionPoint(),
            'exporters': ExporterExtensionPoint(),
            'gui_widgets': GUIWidgetExtensionPoint()
        }
    
    def discover_plugins(self) -> Dict[str, Dict[str, Any]]:
        """プラグイン自動発見"""
        discovered = {}
        
        for plugin_dir in self.plugin_directories:
            if not plugin_dir.exists():
                continue
            
            print(f"🔍 プラグイン検索: {plugin_dir}")
            
            # 1. ディレクトリベース発見
            for item in plugin_dir.iterdir():
                if item.is_dir() and (item / "__init__.py").exists():
                    plugin_info = self._load_plugin_info(item)
                    if plugin_info:
                        discovered[item.name] = plugin_info
                
                # 2. 単一ファイルプラグイン
                elif item.suffix == ".py" and not item.stem.startswith("__"):
                    plugin_info = self._load_file_plugin_info(item)
                    if plugin_info:
                        discovered[item.stem] = plugin_info
        
        return discovered
    
    def _load_plugin_info(self, plugin_path: Path) -> Dict[str, Any]:
        """プラグイン情報読み込み"""
        try:
            # plugin.json メタデータ読み込み
            metadata_file = plugin_path / "plugin.json"
            if metadata_file.exists():
                with open(metadata_file, 'r', encoding='utf-8') as f:
                    metadata = json.load(f)
            else:
                metadata = self._generate_default_metadata(plugin_path)
            
            return {
                'path': plugin_path,
                'metadata': metadata,
                'type': 'directory'
            }
            
        except Exception as e:
            print(f"プラグイン情報読み込みエラー {plugin_path}: {e}")
            return None
    
    def _generate_default_metadata(self, plugin_path: Path) -> Dict[str, Any]:
        """デフォルトメタデータ生成"""
        return {
            'name': plugin_path.name,
            'version': '1.0.0',
            'description': f'プラグイン: {plugin_path.name}',
            'author': 'Unknown',
            'entry_point': 'main.py',
            'extension_points': ['analyzers'],
            'dependencies': [],
            'enabled': True
        }
    
    def load_plugin(self, plugin_name: str, plugin_info: Dict[str, Any]) -> bool:
        """プラグイン読み込み"""
        try:
            print(f"📦 プラグイン読み込み: {plugin_name}")
            
            plugin_path = plugin_info['path']
            metadata = plugin_info['metadata']
            
            # 依存関係チェック
            if not self._check_dependencies(metadata.get('dependencies', [])):
                print(f"❌ 依存関係不足: {plugin_name}")
                return False
            
            # Python モジュール読み込み
            spec = importlib.util.spec_from_file_location(
                plugin_name,
                plugin_path / metadata.get('entry_point', 'main.py')
            )
            
            if spec and spec.loader:
                module = importlib.util.module_from_spec(spec)
                spec.loader.exec_module(module)
                
                # プラグイン初期化
                if hasattr(module, 'initialize_plugin'):
                    plugin_instance = module.initialize_plugin(self)
                    self.loaded_plugins[plugin_name] = {
                        'instance': plugin_instance,
                        'module': module,
                        'metadata': metadata
                    }
                    
                    print(f"✅ プラグイン読み込み成功: {plugin_name}")
                    return True
                else:
                    print(f"❌ initialize_plugin 関数が見つかりません: {plugin_name}")
            
        except Exception as e:
            print(f"❌ プラグイン読み込みエラー {plugin_name}: {e}")
        
        return False
    
    def _check_dependencies(self, dependencies: List[str]) -> bool:
        """依存関係チェック"""
        for dependency in dependencies:
            try:
                importlib.import_module(dependency)
            except ImportError:
                print(f"⚠️  依存関係不足: {dependency}")
                return False
        return True
    
    def load_all_plugins(self):
        """全プラグインの読み込み"""
        discovered = self.discover_plugins()
        
        loaded_count = 0
        for plugin_name, plugin_info in discovered.items():
            metadata = plugin_info['metadata']
            
            if metadata.get('enabled', True):
                if self.load_plugin(plugin_name, plugin_info):
                    loaded_count += 1
            else:
                print(f"⏸️  プラグイン無効: {plugin_name}")
        
        print(f"📊 プラグイン読み込み完了: {loaded_count}/{len(discovered)}")
    
    def get_extension_point(self, name: str) -> ExtensionPoint:
        """拡張ポイント取得"""
        return self.extension_points.get(name)
    
    def register_extension(self, extension_point_name: str, extension):
        """拡張登録"""
        ext_point = self.get_extension_point(extension_point_name)
        if ext_point:
            ext_point.register(extension)
        else:
            raise ValueError(f"未知の拡張ポイント: {extension_point_name}")
```

**初心者向け: importlib による動的インポート**

```python
import importlib.util

# 静的インポート（通常の方法）
import my_module  # my_module.py が必要

# 動的インポート（プラグインシステム用）
def load_module_from_path(module_name: str, file_path: str):
    """ファイルパスからモジュールを読み込み"""
    spec = importlib.util.spec_from_file_location(module_name, file_path)
    #                    ↑ モジュール名        ↑ ファイルパス
    
    if spec and spec.loader:
        module = importlib.util.module_from_spec(spec)
        spec.loader.exec_module(module)  # 実際にコードを実行
        return module
    return None

# 使用例
plugin_module = load_module_from_path("sentiment_analyzer", "/plugins/sentiment_analyzer.py")
if plugin_module and hasattr(plugin_module, 'SentimentAnalyzer'):
    analyzer = plugin_module.SentimentAnalyzer()
```

---

## **🪝 フックシステムの実装**

### **イベントドリブンフックアーキテクチャ**

#### **📢 フック管理システム**

```python
from typing import Callable, List, Any, Dict
from dataclasses import dataclass
from enum import Enum
import asyncio
import inspect

class HookPriority(Enum):
    """フック優先度"""
    HIGHEST = 1
    HIGH = 2
    NORMAL = 3
    LOW = 4
    LOWEST = 5

@dataclass
class HookRegistration:
    """フック登録情報"""
    callback: Callable
    priority: HookPriority
    once: bool = False  # 一度だけ実行
    async_callback: bool = False
    conditions: Dict[str, Any] = None

class HookManager:
    """フックシステム管理"""
    
    def __init__(self):
        self.hooks: Dict[str, List[HookRegistration]] = {}
        self.hook_history: List[Dict[str, Any]] = []
        self.enabled = True
    
    def register(self, 
                event_name: str, 
                callback: Callable, 
                priority: HookPriority = HookPriority.NORMAL,
                once: bool = False,
                conditions: Dict[str, Any] = None):
        """フック登録"""
        
        # 非同期関数チェック
        is_async = asyncio.iscoroutinefunction(callback)
        
        registration = HookRegistration(
            callback=callback,
            priority=priority,
            once=once,
            async_callback=is_async,
            conditions=conditions or {}
        )
        
        if event_name not in self.hooks:
            self.hooks[event_name] = []
        
        self.hooks[event_name].append(registration)
        
        # 優先度順にソート
        self.hooks[event_name].sort(key=lambda x: x.priority.value)
        
        print(f"🪝 フック登録: {event_name} → {callback.__name__} (優先度: {priority.name})")
    
    def unregister(self, event_name: str, callback: Callable):
        """フック解除"""
        if event_name in self.hooks:
            self.hooks[event_name] = [
                reg for reg in self.hooks[event_name] 
                if reg.callback != callback
            ]
            print(f"🗑️ フック解除: {event_name} → {callback.__name__}")
    
    async def trigger_async(self, event_name: str, *args, **kwargs) -> List[Any]:
        """非同期フック実行"""
        if not self.enabled or event_name not in self.hooks:
            return []
        
        results = []
        hooks_to_remove = []
        
        for i, registration in enumerate(self.hooks[event_name]):
            try:
                # 条件チェック
                if not self._check_conditions(registration.conditions, kwargs):
                    continue
                
                # フック実行
                if registration.async_callback:
                    result = await registration.callback(*args, **kwargs)
                else:
                    result = registration.callback(*args, **kwargs)
                
                results.append(result)
                
                # 履歴記録
                self._record_hook_execution(event_name, registration, args, kwargs, result)
                
                # 一回限りフックの記録
                if registration.once:
                    hooks_to_remove.append(i)
                
            except Exception as e:
                print(f"❌ フック実行エラー {event_name}::{registration.callback.__name__}: {e}")
                self._record_hook_error(event_name, registration, e)
        
        # 一回限りフックを削除
        for i in reversed(hooks_to_remove):
            self.hooks[event_name].pop(i)
        
        return results
    
    def trigger(self, event_name: str, *args, **kwargs) -> List[Any]:
        """同期フック実行"""
        if not self.enabled or event_name not in self.hooks:
            return []
        
        results = []
        hooks_to_remove = []
        
        for i, registration in enumerate(self.hooks[event_name]):
            try:
                # 非同期フックは同期実行でスキップ
                if registration.async_callback:
                    print(f"⚠️  非同期フック無視: {registration.callback.__name__}")
                    continue
                
                # 条件チェック
                if not self._check_conditions(registration.conditions, kwargs):
                    continue
                
                result = registration.callback(*args, **kwargs)
                results.append(result)
                
                self._record_hook_execution(event_name, registration, args, kwargs, result)
                
                if registration.once:
                    hooks_to_remove.append(i)
                
            except Exception as e:
                print(f"❌ フック実行エラー {event_name}::{registration.callback.__name__}: {e}")
                self._record_hook_error(event_name, registration, e)
        
        for i in reversed(hooks_to_remove):
            self.hooks[event_name].pop(i)
        
        return results
    
    def _check_conditions(self, conditions: Dict[str, Any], kwargs: Dict[str, Any]) -> bool:
        """条件チェック"""
        if not conditions:
            return True
        
        for key, expected_value in conditions.items():
            if key not in kwargs or kwargs[key] != expected_value:
                return False
        return True
    
    def _record_hook_execution(self, event_name: str, registration: HookRegistration, 
                             args: tuple, kwargs: Dict[str, Any], result: Any):
        """フック実行履歴記録"""
        from datetime import datetime
        
        self.hook_history.append({
            'timestamp': datetime.now().isoformat(),
            'event': event_name,
            'callback': registration.callback.__name__,
            'priority': registration.priority.name,
            'success': True,
            'result_type': type(result).__name__ if result is not None else None
        })
    
    def _record_hook_error(self, event_name: str, registration: HookRegistration, error: Exception):
        """フックエラー履歴記録"""
        from datetime import datetime
        
        self.hook_history.append({
            'timestamp': datetime.now().isoformat(),
            'event': event_name,
            'callback': registration.callback.__name__,
            'priority': registration.priority.name,
            'success': False,
            'error': str(error),
            'error_type': type(error).__name__
        })
    
    def get_registered_hooks(self) -> Dict[str, List[str]]:
        """登録済みフック一覧取得"""
        return {
            event: [reg.callback.__name__ for reg in registrations]
            for event, registrations in self.hooks.items()
        }
    
    def clear_hooks(self, event_name: str = None):
        """フッククリア"""
        if event_name:
            if event_name in self.hooks:
                del self.hooks[event_name]
                print(f"🗑️ フッククリア: {event_name}")
        else:
            self.hooks.clear()
            print("🗑️ 全フッククリア")
```

#### **🎯 コアシステム統合**

```python
class ExtensibleYouTubeSystem:
    """拡張可能なYouTubeナレッジシステム"""
    
    def __init__(self):
        self.hook_manager = HookManager()
        self.plugin_manager = PluginManager()
        
        # 標準フックポイントの定義
        self.setup_standard_hooks()
        
        # プラグイン読み込み
        self.plugin_manager.load_all_plugins()
    
    def setup_standard_hooks(self):
        """標準フックポイント定義"""
        self.hook_points = {
            # データ収集フック
            'before_collect_videos': "動画収集開始前",
            'after_collect_videos': "動画収集完了後", 
            'video_collected': "個別動画収集時",
            
            # 分析フック
            'before_analyze_video': "動画分析開始前",
            'after_analyze_video': "動画分析完了後",
            'analysis_failed': "分析失敗時",
            
            # データ操作フック
            'before_save_video': "動画保存前",
            'after_save_video': "動画保存後", 
            'video_deleted': "動画削除時",
            
            # GUI フック
            'gui_startup': "GUI起動時",
            'video_selected': "動画選択時",
            'menu_action': "メニュー操作時",
            
            # システムフック
            'system_startup': "システム起動時",
            'system_shutdown': "システム終了時",
            'error_occurred': "エラー発生時"
        }
        
        print(f"📋 標準フックポイント定義: {len(self.hook_points)}個")
    
    def collect_videos_with_hooks(self, playlist_id: str, max_videos: int = None):
        """フック付き動画収集"""
        
        # 収集開始前フック
        hook_results = self.hook_manager.trigger(
            'before_collect_videos',
            playlist_id=playlist_id,
            max_videos=max_videos
        )
        
        # フック結果による動作変更
        modified_params = self._process_hook_results(hook_results, {
            'playlist_id': playlist_id,
            'max_videos': max_videos
        })
        
        try:
            # 実際の収集処理
            collected_videos = self._perform_collection(
                modified_params['playlist_id'],
                modified_params['max_videos']
            )
            
            # 個別動画フック
            for video in collected_videos:
                self.hook_manager.trigger(
                    'video_collected',
                    video=video,
                    playlist_id=playlist_id
                )
            
            # 収集完了後フック
            self.hook_manager.trigger(
                'after_collect_videos',
                videos=collected_videos,
                success=True,
                count=len(collected_videos)
            )
            
            return collected_videos
            
        except Exception as e:
            # エラーフック
            self.hook_manager.trigger(
                'error_occurred',
                error=e,
                operation='collect_videos',
                context={'playlist_id': playlist_id}
            )
            raise
    
    def analyze_video_with_hooks(self, video, analyzer_name: str = None):
        """フック付き動画分析"""
        
        # 分析開始前フック
        self.hook_manager.trigger(
            'before_analyze_video',
            video=video,
            analyzer=analyzer_name
        )
        
        try:
            # 分析実行
            analysis_result = self._perform_analysis(video, analyzer_name)
            
            # 分析完了後フック
            self.hook_manager.trigger(
                'after_analyze_video',
                video=video,
                result=analysis_result,
                success=True,
                analyzer=analyzer_name
            )
            
            return analysis_result
            
        except Exception as e:
            # 分析失敗フック
            self.hook_manager.trigger(
                'analysis_failed',
                video=video,
                error=e,
                analyzer=analyzer_name
            )
            raise
    
    def _process_hook_results(self, hook_results: List[Any], original_params: Dict) -> Dict:
        """フック結果による パラメータ変更処理"""
        modified_params = original_params.copy()
        
        for result in hook_results:
            if isinstance(result, dict) and 'modify_params' in result:
                modifications = result['modify_params']
                modified_params.update(modifications)
                print(f"🔧 パラメータ変更: {modifications}")
        
        return modified_params
```

**フック使用例: カスタム分析結果の後処理**

```python
# プラグインでのフック登録例
def initialize_plugin(system):
    """プラグイン初期化"""
    
    # 分析完了後にカスタム処理を追加
    system.hook_manager.register(
        'after_analyze_video',
        enhance_analysis_result,
        priority=HookPriority.HIGH
    )
    
    # エラー発生時の通知処理
    system.hook_manager.register(
        'error_occurred', 
        notify_error_to_external_service,
        conditions={'severity': 'critical'}
    )

def enhance_analysis_result(video, result, success, **kwargs):
    """分析結果の拡張処理"""
    if success and result:
        # カスタム処理: 感情スコア追加
        if 'creative_insight' in result:
            result['sentiment_score'] = calculate_sentiment_score(result['creative_insight'])
            print(f"🎭 感情スコア追加: {result['sentiment_score']}")
        
        # 結果の外部API送信
        send_to_analytics_service(video.metadata.id, result)
    
    return result

def notify_error_to_external_service(error, operation, context, **kwargs):
    """エラーの外部通知"""
    error_data = {
        'operation': operation,
        'error_message': str(error),
        'context': context,
        'timestamp': datetime.now().isoformat()
    }
    
    # Slack/Discord等への通知
    send_notification(error_data)
```

---

## **🔍 カスタム分析器の作成**

### **分析器プラグインインターフェース**

#### **📐 基底クラス設計**

```python
from abc import ABC, abstractmethod
from typing import Dict, List, Any, Optional
from dataclasses import dataclass
from enum import Enum

class AnalysisType(Enum):
    """分析タイプ"""
    TEXT_ANALYSIS = "text_analysis"
    SENTIMENT_ANALYSIS = "sentiment_analysis" 
    TOPIC_EXTRACTION = "topic_extraction"
    KEYWORD_EXTRACTION = "keyword_extraction"
    VISUAL_ANALYSIS = "visual_analysis"
    AUDIO_ANALYSIS = "audio_analysis"
    METADATA_ANALYSIS = "metadata_analysis"

@dataclass
class AnalysisResult:
    """分析結果標準形式"""
    analyzer_name: str
    analysis_type: AnalysisType
    confidence: float  # 0.0 - 1.0
    data: Dict[str, Any]
    metadata: Dict[str, Any]
    processing_time: float
    error: Optional[str] = None

class BaseAnalyzer(ABC):
    """分析器基底クラス"""
    
    def __init__(self, name: str, version: str = "1.0.0"):
        self.name = name
        self.version = version
        self.supported_types = self.get_supported_types()
        self.config = self.get_default_config()
    
    @abstractmethod
    def get_supported_types(self) -> List[AnalysisType]:
        """サポートする分析タイプ"""
        pass
    
    @abstractmethod 
    def analyze(self, video, analysis_type: AnalysisType = None) -> AnalysisResult:
        """分析実行"""
        pass
    
    @abstractmethod
    def can_handle(self, video) -> bool:
        """この動画を分析可能かチェック"""
        pass
    
    def get_default_config(self) -> Dict[str, Any]:
        """デフォルト設定"""
        return {
            'enabled': True,
            'timeout': 30,
            'max_retries': 3
        }
    
    def validate_config(self, config: Dict[str, Any]) -> bool:
        """設定の妥当性チェック"""
        required_keys = ['enabled', 'timeout', 'max_retries']
        return all(key in config for key in required_keys)
    
    def get_info(self) -> Dict[str, Any]:
        """分析器情報取得"""
        return {
            'name': self.name,
            'version': self.version,
            'supported_types': [t.value for t in self.supported_types],
            'config': self.config
        }

class SentimentAnalyzer(BaseAnalyzer):
    """感情分析器の実装例"""
    
    def __init__(self):
        super().__init__("SentimentAnalyzer", "1.2.0")
        self.model = None
        self._initialize_model()
    
    def get_supported_types(self) -> List[AnalysisType]:
        return [AnalysisType.SENTIMENT_ANALYSIS, AnalysisType.TEXT_ANALYSIS]
    
    def _initialize_model(self):
        """分析モデル初期化"""
        try:
            # 実際の実装では外部ライブラリを使用
            # from transformers import pipeline
            # self.model = pipeline("sentiment-analysis")
            
            # ダミー実装
            self.model = "sentiment_model_placeholder"
            print(f"✅ {self.name} モデル初期化完了")
        except Exception as e:
            print(f"❌ {self.name} モデル初期化失敗: {e}")
    
    def can_handle(self, video) -> bool:
        """分析可能性チェック"""
        # 説明文またはタイトルがあり、日本語または英語
        if not video.metadata.description and not video.metadata.title:
            return False
        
        text = (video.metadata.description or "") + " " + (video.metadata.title or "")
        return len(text.strip()) > 10  # 最低10文字
    
    def analyze(self, video, analysis_type: AnalysisType = None) -> AnalysisResult:
        """感情分析実行"""
        import time
        start_time = time.time()
        
        try:
            # 分析対象テキスト準備
            text = self._prepare_text(video)
            
            if not text:
                return AnalysisResult(
                    analyzer_name=self.name,
                    analysis_type=AnalysisType.SENTIMENT_ANALYSIS,
                    confidence=0.0,
                    data={},
                    metadata={'error': 'テキストが空'},
                    processing_time=time.time() - start_time,
                    error="分析対象テキストが見つかりません"
                )
            
            # 実際の感情分析（ダミー実装）
            sentiment_result = self._perform_sentiment_analysis(text)
            
            return AnalysisResult(
                analyzer_name=self.name,
                analysis_type=AnalysisType.SENTIMENT_ANALYSIS,
                confidence=sentiment_result['confidence'],
                data={
                    'sentiment': sentiment_result['sentiment'],
                    'scores': sentiment_result['scores'],
                    'keywords': sentiment_result.get('keywords', []),
                    'emotion_breakdown': sentiment_result.get('emotions', {})
                },
                metadata={
                    'text_length': len(text),
                    'language': sentiment_result.get('language', 'unknown'),
                    'model_version': self.version
                },
                processing_time=time.time() - start_time
            )
            
        except Exception as e:
            return AnalysisResult(
                analyzer_name=self.name,
                analysis_type=AnalysisType.SENTIMENT_ANALYSIS,
                confidence=0.0,
                data={},
                metadata={'error_details': str(e)},
                processing_time=time.time() - start_time,
                error=f"分析エラー: {e}"
            )
    
    def _prepare_text(self, video) -> str:
        """分析用テキスト準備"""
        texts = []
        
        if video.metadata.title:
            texts.append(f"タイトル: {video.metadata.title}")
        
        if video.metadata.description:
            # 長すぎる説明文は切り詰め
            desc = video.metadata.description[:1000]
            texts.append(f"説明: {desc}")
        
        return "\n".join(texts)
    
    def _perform_sentiment_analysis(self, text: str) -> Dict[str, Any]:
        """感情分析実行（ダミー実装）"""
        # 実際の実装では機械学習モデルを使用
        import random
        
        sentiments = ['positive', 'negative', 'neutral']
        sentiment = random.choice(sentiments)
        confidence = random.uniform(0.6, 0.95)
        
        scores = {
            'positive': random.uniform(0.0, 1.0),
            'negative': random.uniform(0.0, 1.0), 
            'neutral': random.uniform(0.0, 1.0)
        }
        
        # 正規化
        total = sum(scores.values())
        scores = {k: v/total for k, v in scores.items()}
        
        return {
            'sentiment': sentiment,
            'confidence': confidence,
            'scores': scores,
            'language': 'ja',
            'keywords': ['音楽', 'クリエイティブ', '制作'],
            'emotions': {
                'joy': random.uniform(0.0, 0.5),
                'sadness': random.uniform(0.0, 0.3),
                'excitement': random.uniform(0.0, 0.7)
            }
        }

class TopicExtractor(BaseAnalyzer):
    """トピック抽出器の実装例"""
    
    def __init__(self):
        super().__init__("TopicExtractor", "1.0.0")
    
    def get_supported_types(self) -> List[AnalysisType]:
        return [AnalysisType.TOPIC_EXTRACTION, AnalysisType.KEYWORD_EXTRACTION]
    
    def can_handle(self, video) -> bool:
        return bool(video.metadata.description and len(video.metadata.description) > 50)
    
    def analyze(self, video, analysis_type: AnalysisType = None) -> AnalysisResult:
        """トピック抽出実行"""
        import time
        start_time = time.time()
        
        try:
            topics = self._extract_topics(video.metadata.description)
            keywords = self._extract_keywords(video.metadata.description)
            
            return AnalysisResult(
                analyzer_name=self.name,
                analysis_type=AnalysisType.TOPIC_EXTRACTION,
                confidence=0.8,
                data={
                    'topics': topics,
                    'keywords': keywords,
                    'categories': self._categorize_content(topics)
                },
                metadata={
                    'text_length': len(video.metadata.description),
                    'topics_count': len(topics),
                    'keywords_count': len(keywords)
                },
                processing_time=time.time() - start_time
            )
            
        except Exception as e:
            return AnalysisResult(
                analyzer_name=self.name,
                analysis_type=AnalysisType.TOPIC_EXTRACTION,
                confidence=0.0,
                data={},
                metadata={},
                processing_time=time.time() - start_time,
                error=str(e)
            )
    
    def _extract_topics(self, text: str) -> List[Dict[str, Any]]:
        """トピック抽出（ダミー実装）"""
        # 実装例：TF-IDF, LDA, BERT等を使用
        import random
        
        topics = [
            {'name': '音楽制作', 'score': random.uniform(0.7, 0.9)},
            {'name': 'DAW操作', 'score': random.uniform(0.5, 0.8)},
            {'name': 'ミキシング', 'score': random.uniform(0.4, 0.7)},
            {'name': 'クリエイティブ', 'score': random.uniform(0.6, 0.8)}
        ]
        
        return sorted(topics, key=lambda x: x['score'], reverse=True)[:3]
    
    def _extract_keywords(self, text: str) -> List[str]:
        """キーワード抽出（ダミー実装）"""
        # 実装例：mecab, spacy, transformers等を使用
        keywords = ['DTM', 'ボカロ', 'Cubase', 'ギター', 'シンセサイザー']
        import random
        return random.sample(keywords, min(len(keywords), 5))
    
    def _categorize_content(self, topics: List[Dict[str, Any]]) -> List[str]:
        """コンテンツカテゴリ化"""
        categories = []
        
        for topic in topics:
            topic_name = topic['name'].lower()
            if any(keyword in topic_name for keyword in ['音楽', 'ミュージック', 'サウンド']):
                categories.append('音楽')
            elif any(keyword in topic_name for keyword in ['制作', 'daw', 'ミキシング']):
                categories.append('制作技術')
            elif any(keyword in topic_name for keyword in ['クリエイティブ', '創作']):
                categories.append('クリエイティブ')
        
        return list(set(categories))  # 重複除去
```

### **分析器統合システム**

#### **🔄 分析パイプライン**

```python
class AnalysisPipeline:
    """分析パイプライン管理"""
    
    def __init__(self, hook_manager: HookManager):
        self.hook_manager = hook_manager
        self.analyzers: Dict[str, BaseAnalyzer] = {}
        self.pipeline_configs = {}
        self.analysis_cache = {}
    
    def register_analyzer(self, analyzer: BaseAnalyzer):
        """分析器登録"""
        if not isinstance(analyzer, BaseAnalyzer):
            raise ValueError("BaseAnalyzer を継承した分析器が必要です")
        
        self.analyzers[analyzer.name] = analyzer
        print(f"🔍 分析器登録: {analyzer.name} (対応タイプ: {[t.value for t in analyzer.supported_types]})")
    
    def create_pipeline(self, name: str, analyzer_sequence: List[str], config: Dict[str, Any] = None):
        """分析パイプライン作成"""
        # 分析器の存在確認
        for analyzer_name in analyzer_sequence:
            if analyzer_name not in self.analyzers:
                raise ValueError(f"未登録の分析器: {analyzer_name}")
        
        self.pipeline_configs[name] = {
            'sequence': analyzer_sequence,
            'config': config or {},
            'parallel': config.get('parallel', False) if config else False
        }
        
        print(f"📋 パイプライン作成: {name} → {analyzer_sequence}")
    
    def run_pipeline(self, pipeline_name: str, video, **kwargs) -> Dict[str, AnalysisResult]:
        """パイプライン実行"""
        if pipeline_name not in self.pipeline_configs:
            raise ValueError(f"未知のパイプライン: {pipeline_name}")
        
        config = self.pipeline_configs[pipeline_name]
        sequence = config['sequence']
        parallel = config['parallel']
        
        # キャッシュチェック
        cache_key = f"{pipeline_name}_{video.metadata.id}"
        if cache_key in self.analysis_cache:
            print(f"📦 キャッシュヒット: {cache_key}")
            return self.analysis_cache[cache_key]
        
        print(f"🚀 パイプライン実行: {pipeline_name} ({'並列' if parallel else '順次'})")
        
        # フック: パイプライン開始前
        self.hook_manager.trigger(
            'before_pipeline_execution',
            pipeline_name=pipeline_name,
            video=video,
            analyzers=sequence
        )
        
        try:
            if parallel:
                results = self._run_parallel_analysis(sequence, video, **kwargs)
            else:
                results = self._run_sequential_analysis(sequence, video, **kwargs)
            
            # 結果をキャッシュ
            self.analysis_cache[cache_key] = results
            
            # フック: パイプライン完了後
            self.hook_manager.trigger(
                'after_pipeline_execution',
                pipeline_name=pipeline_name,
                video=video,
                results=results,
                success=True
            )
            
            return results
            
        except Exception as e:
            # フック: パイプラインエラー
            self.hook_manager.trigger(
                'pipeline_execution_error',
                pipeline_name=pipeline_name,
                video=video,
                error=e
            )
            raise
    
    def _run_sequential_analysis(self, sequence: List[str], video, **kwargs) -> Dict[str, AnalysisResult]:
        """順次分析実行"""
        results = {}
        
        for analyzer_name in sequence:
            analyzer = self.analyzers[analyzer_name]
            
            if not analyzer.can_handle(video):
                print(f"⏭️  スキップ: {analyzer_name} (ハンドル不可)")
                continue
            
            print(f"🔍 分析実行: {analyzer_name}")
            
            try:
                result = analyzer.analyze(video, **kwargs)
                results[analyzer_name] = result
                
                # 前の結果を次の分析器に渡す（チェーン処理）
                if 'chain_results' in kwargs:
                    kwargs['previous_results'] = results
                
            except Exception as e:
                error_result = AnalysisResult(
                    analyzer_name=analyzer_name,
                    analysis_type=analyzer.supported_types[0] if analyzer.supported_types else AnalysisType.TEXT_ANALYSIS,
                    confidence=0.0,
                    data={},
                    metadata={},
                    processing_time=0.0,
                    error=str(e)
                )
                results[analyzer_name] = error_result
                print(f"❌ 分析エラー {analyzer_name}: {e}")
        
        return results
    
    def _run_parallel_analysis(self, sequence: List[str], video, **kwargs) -> Dict[str, AnalysisResult]:
        """並列分析実行"""
        import concurrent.futures
        import threading
        
        results = {}
        
        def analyze_single(analyzer_name: str) -> tuple[str, AnalysisResult]:
            analyzer = self.analyzers[analyzer_name]
            
            if not analyzer.can_handle(video):
                return analyzer_name, None
            
            try:
                result = analyzer.analyze(video, **kwargs)
                return analyzer_name, result
            except Exception as e:
                error_result = AnalysisResult(
                    analyzer_name=analyzer_name,
                    analysis_type=analyzer.supported_types[0] if analyzer.supported_types else AnalysisType.TEXT_ANALYSIS,
                    confidence=0.0,
                    data={},
                    metadata={},
                    processing_time=0.0,
                    error=str(e)
                )
                return analyzer_name, error_result
        
        # 並列実行
        with concurrent.futures.ThreadPoolExecutor(max_workers=3) as executor:
            future_to_analyzer = {
                executor.submit(analyze_single, analyzer_name): analyzer_name
                for analyzer_name in sequence
            }
            
            for future in concurrent.futures.as_completed(future_to_analyzer):
                analyzer_name, result = future.result()
                if result:
                    results[analyzer_name] = result
                    print(f"✅ 並列分析完了: {analyzer_name}")
        
        return results
    
    def get_available_analyzers(self) -> Dict[str, Dict[str, Any]]:
        """利用可能分析器一覧"""
        return {
            name: analyzer.get_info()
            for name, analyzer in self.analyzers.items()
        }
    
    def clear_cache(self, video_id: str = None):
        """分析キャッシュクリア"""
        if video_id:
            keys_to_remove = [key for key in self.analysis_cache.keys() if video_id in key]
            for key in keys_to_remove:
                del self.analysis_cache[key]
            print(f"🗑️ キャッシュクリア: {video_id}")
        else:
            self.analysis_cache.clear()
            print("🗑️ 全分析キャッシュクリア")
```

---

## **🌐 外部API連携拡張**

### **API連携フレームワーク**

#### **🔌 汎用APIコネクタ**

```python
import requests
import asyncio
import aiohttp
from typing import Optional, Dict, Any, List
from dataclasses import dataclass
from enum import Enum
import time
import json

class APIMethod(Enum):
    """HTTP メソッド"""
    GET = "GET"
    POST = "POST"
    PUT = "PUT"
    DELETE = "DELETE"
    PATCH = "PATCH"

@dataclass
class APIResponse:
    """API レスポンス"""
    status_code: int
    data: Any
    headers: Dict[str, str]
    error: Optional[str] = None
    processing_time: float = 0.0

class ExternalAPIConnector:
    """外部API連携基底クラス"""
    
    def __init__(self, base_url: str, api_key: str = None, timeout: int = 30):
        self.base_url = base_url.rstrip('/')
        self.api_key = api_key
        self.timeout = timeout
        self.session = requests.Session()
        self.rate_limiter = RateLimiter()
        
        # デフォルトヘッダー設定
        self.session.headers.update({
            'User-Agent': 'YouTube-Knowledge-System/2.0',
            'Content-Type': 'application/json'
        })
        
        if api_key:
            self.session.headers['Authorization'] = f'Bearer {api_key}'
    
    def request(self, 
                method: APIMethod, 
                endpoint: str, 
                params: Dict[str, Any] = None,
                data: Dict[str, Any] = None,
                headers: Dict[str, str] = None) -> APIResponse:
        """API リクエスト実行"""
        
        # レート制限チェック
        self.rate_limiter.wait_if_needed()
        
        url = f"{self.base_url}/{endpoint.lstrip('/')}"
        
        # リクエストヘッダー準備
        request_headers = self.session.headers.copy()
        if headers:
            request_headers.update(headers)
        
        start_time = time.time()
        
        try:
            response = self.session.request(
                method=method.value,
                url=url,
                params=params,
                json=data if data else None,
                headers=request_headers,
                timeout=self.timeout
            )
            
            processing_time = time.time() - start_time
            
            # レスポンス処理
            try:
                response_data = response.json() if response.content else {}
            except json.JSONDecodeError:
                response_data = response.text
            
            return APIResponse(
                status_code=response.status_code,
                data=response_data,
                headers=dict(response.headers),
                processing_time=processing_time
            )
            
        except requests.exceptions.RequestException as e:
            processing_time = time.time() - start_time
            
            return APIResponse(
                status_code=0,
                data={},
                headers={},
                error=str(e),
                processing_time=processing_time
            )
    
    async def async_request(self, 
                           method: APIMethod, 
                           endpoint: str,
                           params: Dict[str, Any] = None,
                           data: Dict[str, Any] = None,
                           headers: Dict[str, str] = None) -> APIResponse:
        """非同期APIリクエスト"""
        
        url = f"{self.base_url}/{endpoint.lstrip('/')}"
        
        request_headers = self.session.headers.copy()
        if headers:
            request_headers.update(headers)
        
        start_time = time.time()
        
        try:
            async with aiohttp.ClientSession(timeout=aiohttp.ClientTimeout(total=self.timeout)) as session:
                async with session.request(
                    method=method.value,
                    url=url,
                    params=params,
                    json=data,
                    headers=request_headers
                ) as response:
                    processing_time = time.time() - start_time
                    
                    try:
                        response_data = await response.json()
                    except:
                        response_data = await response.text()
                    
                    return APIResponse(
                        status_code=response.status,
                        data=response_data,
                        headers=dict(response.headers),
                        processing_time=processing_time
                    )
                    
        except Exception as e:
            processing_time = time.time() - start_time
            
            return APIResponse(
                status_code=0,
                data={},
                headers={},
                error=str(e),
                processing_time=processing_time
            )

class RateLimiter:
    """レート制限管理"""
    
    def __init__(self, requests_per_minute: int = 60):
        self.requests_per_minute = requests_per_minute
        self.request_times = []
    
    def wait_if_needed(self):
        """必要に応じて待機"""
        now = time.time()
        
        # 1分以内のリクエストを保持
        self.request_times = [t for t in self.request_times if now - t < 60]
        
        if len(self.request_times) >= self.requests_per_minute:
            # 最古のリクエストから1分経つまで待機
            sleep_time = 60 - (now - self.request_times[0])
            if sleep_time > 0:
                print(f"⏱️  レート制限: {sleep_time:.1f}秒待機")
                time.sleep(sleep_time)
        
        self.request_times.append(now)

# 具体的なAPI連携実装例
class SlackNotifier(ExternalAPIConnector):
    """Slack通知API"""
    
    def __init__(self, webhook_url: str):
        # Slack Webhook は認証不要
        super().__init__(base_url="", api_key=None)
        self.webhook_url = webhook_url
    
    def send_message(self, text: str, channel: str = None, username: str = "YouTube-Knowledge-Bot") -> bool:
        """メッセージ送信"""
        payload = {
            'text': text,
            'username': username
        }
        
        if channel:
            payload['channel'] = channel
        
        try:
            response = requests.post(
                self.webhook_url,
                json=payload,
                timeout=self.timeout
            )
            
            return response.status_code == 200
            
        except Exception as e:
            print(f"Slack通知エラー: {e}")
            return False
    
    def send_analysis_report(self, video_title: str, analysis_results: Dict[str, AnalysisResult]) -> bool:
        """分析結果レポート送信"""
        
        # レポート作成
        message_lines = [
            f"📊 *動画分析完了*",
            f"🎵 動画: {video_title}",
            ""
        ]
        
        for analyzer_name, result in analysis_results.items():
            if result.error:
                message_lines.append(f"❌ {analyzer_name}: エラー ({result.error})")
            else:
                confidence_emoji = "🟢" if result.confidence > 0.8 else "🟡" if result.confidence > 0.5 else "🔴"
                message_lines.append(f"{confidence_emoji} {analyzer_name}: 信頼度 {result.confidence:.2f}")
        
        message = "\n".join(message_lines)
        return self.send_message(message)

class DiscordWebhook(ExternalAPIConnector):
    """Discord Webhook API"""
    
    def __init__(self, webhook_url: str):
        super().__init__(base_url="", api_key=None)
        self.webhook_url = webhook_url
    
    def send_embed(self, title: str, description: str, color: int = 0x00ff00, fields: List[Dict[str, Any]] = None) -> bool:
        """埋め込みメッセージ送信"""
        
        embed = {
            'title': title,
            'description': description,
            'color': color,
            'timestamp': time.strftime('%Y-%m-%dT%H:%M:%S.000Z', time.gmtime())
        }
        
        if fields:
            embed['fields'] = fields
        
        payload = {'embeds': [embed]}
        
        try:
            response = requests.post(
                self.webhook_url,
                json=payload,
                timeout=self.timeout
            )
            
            return response.status_code == 204  # Discord は 204 を返す
            
        except Exception as e:
            print(f"Discord通知エラー: {e}")
            return False

class GoogleSheetsAPI(ExternalAPIConnector):
    """Google Sheets API"""
    
    def __init__(self, api_key: str, spreadsheet_id: str):
        super().__init__(
            base_url="https://sheets.googleapis.com/v4/spreadsheets",
            api_key=api_key
        )
        self.spreadsheet_id = spreadsheet_id
    
    def append_row(self, sheet_name: str, values: List[Any]) -> bool:
        """行追加"""
        endpoint = f"{self.spreadsheet_id}/values/{sheet_name}:append"
        
        data = {
            'values': [values],
            'majorDimension': 'ROWS'
        }
        
        response = self.request(
            APIMethod.POST,
            endpoint,
            params={'valueInputOption': 'RAW'},
            data=data
        )
        
        return response.status_code == 200
    
    def export_analysis_results(self, results: Dict[str, AnalysisResult]) -> bool:
        """分析結果エクスポート"""
        
        # ヘッダー行（初回のみ）
        headers = ['動画ID', '分析器', '信頼度', 'エラー', '処理時間', '分析日時']
        
        # データ行作成
        for analyzer_name, result in results.items():
            row_data = [
                result.metadata.get('video_id', ''),
                analyzer_name,
                result.confidence,
                result.error or '',
                result.processing_time,
                time.strftime('%Y-%m-%d %H:%M:%S')
            ]
            
            if not self.append_row('分析結果', row_data):
                return False
        
        return True
```

### **API連携プラグインの統合**

#### **🔗 統合管理システム**

```python
class ExternalIntegrationManager:
    """外部連携管理"""
    
    def __init__(self, hook_manager: HookManager, config: Dict[str, Any] = None):
        self.hook_manager = hook_manager
        self.config = config or {}
        self.connectors: Dict[str, ExternalAPIConnector] = {}
        self.integration_history = []
        
        self.setup_integrations()
        self.register_hooks()
    
    def setup_integrations(self):
        """連携サービス設定"""
        
        # Slack連携設定
        if 'slack' in self.config and self.config['slack'].get('enabled'):
            webhook_url = self.config['slack']['webhook_url']
            self.connectors['slack'] = SlackNotifier(webhook_url)
            print("✅ Slack連携設定完了")
        
        # Discord連携設定
        if 'discord' in self.config and self.config['discord'].get('enabled'):
            webhook_url = self.config['discord']['webhook_url']
            self.connectors['discord'] = DiscordWebhook(webhook_url)
            print("✅ Discord連携設定完了")
        
        # Google Sheets連携設定
        if 'google_sheets' in self.config and self.config['google_sheets'].get('enabled'):
            api_key = self.config['google_sheets']['api_key']
            spreadsheet_id = self.config['google_sheets']['spreadsheet_id']
            self.connectors['google_sheets'] = GoogleSheetsAPI(api_key, spreadsheet_id)
            print("✅ Google Sheets連携設定完了")
    
    def register_hooks(self):
        """フック登録"""
        
        # 分析完了時の通知
        self.hook_manager.register(
            'after_analyze_video',
            self.on_analysis_complete,
            priority=HookPriority.LOW  # 最後に実行
        )
        
        # エラー発生時の通知
        self.hook_manager.register(
            'error_occurred',
            self.on_error_occurred,
            priority=HookPriority.HIGH
        )
        
        # システム統計の定期送信
        self.hook_manager.register(
            'daily_report',
            self.send_daily_report
        )
    
    def on_analysis_complete(self, video, result, success, **kwargs):
        """分析完了時処理"""
        if not success:
            return
        
        try:
            # Slack通知
            if 'slack' in self.connectors:
                self.connectors['slack'].send_analysis_report(
                    video.metadata.title,
                    {'analyzer': result} if isinstance(result, AnalysisResult) else result
                )
            
            # Google Sheets エクスポート
            if 'google_sheets' in self.connectors:
                self.connectors['google_sheets'].export_analysis_results(
                    {'analyzer': result} if isinstance(result, AnalysisResult) else result
                )
            
            self._record_integration('analysis_notification', True)
            
        except Exception as e:
            print(f"外部連携エラー: {e}")
            self._record_integration('analysis_notification', False, str(e))
    
    def on_error_occurred(self, error, operation, context, **kwargs):
        """エラー発生時処理"""
        
        error_level = self._determine_error_level(error, operation)
        
        if error_level in ['critical', 'high']:
            try:
                # 重要エラーの即座通知
                if 'slack' in self.connectors:
                    message = f"🚨 *システムエラー発生*\n操作: {operation}\nエラー: {str(error)}"
                    self.connectors['slack'].send_message(message)
                
                if 'discord' in self.connectors:
                    self.connectors['discord'].send_embed(
                        title="🚨 システムエラー",
                        description=f"操作: {operation}\nエラー: {str(error)}",
                        color=0xff0000,  # 赤色
                        fields=[
                            {'name': 'レベル', 'value': error_level, 'inline': True},
                            {'name': '時刻', 'value': time.strftime('%Y-%m-%d %H:%M:%S'), 'inline': True}
                        ]
                    )
                
                self._record_integration('error_notification', True)
                
            except Exception as e:
                print(f"エラー通知失敗: {e}")
                self._record_integration('error_notification', False, str(e))
    
    def send_daily_report(self, **kwargs):
        """日次レポート送信"""
        try:
            from storage.unified_storage import get_storage
            storage = get_storage()
            stats = storage.get_statistics()
            
            # レポート作成
            report_text = f"""📊 *YouTube Knowledge System 日次レポート*

📈 *統計情報*
• 総動画数: {stats['total_videos']}
• 分析済み: {stats['analyzed_videos']}
• 成功率: {stats['analysis_success_rate']:.1%}
• プレイリスト数: {stats['total_playlists']}

🎯 *パフォーマンス*
• クリエイター数: {stats['total_creators']}
• テーマ数: {stats['total_themes']}
• 最終更新: {stats['last_updated']}"""
            
            # Slack送信
            if 'slack' in self.connectors:
                self.connectors['slack'].send_message(report_text)
            
            # Discord送信（埋め込み形式）
            if 'discord' in self.connectors:
                fields = [
                    {'name': '総動画数', 'value': str(stats['total_videos']), 'inline': True},
                    {'name': '分析済み', 'value': str(stats['analyzed_videos']), 'inline': True},
                    {'name': '成功率', 'value': f"{stats['analysis_success_rate']:.1%}", 'inline': True}
                ]
                
                self.connectors['discord'].send_embed(
                    title="📊 日次レポート",
                    description="YouTube Knowledge System の統計情報",
                    color=0x00ff00,
                    fields=fields
                )
            
            self._record_integration('daily_report', True)
            
        except Exception as e:
            print(f"日次レポート送信エラー: {e}")
            self._record_integration('daily_report', False, str(e))
    
    def _determine_error_level(self, error: Exception, operation: str) -> str:
        """エラーレベル判定"""
        error_message = str(error).lower()
        
        if any(keyword in error_message for keyword in ['critical', 'fatal', 'database', 'corruption']):
            return 'critical'
        elif any(keyword in error_message for keyword in ['api', 'auth', 'permission']):
            return 'high'
        elif any(keyword in error_message for keyword in ['network', 'timeout', 'connection']):
            return 'medium'
        else:
            return 'low'
    
    def _record_integration(self, integration_type: str, success: bool, error: str = None):
        """連携履歴記録"""
        record = {
            'timestamp': time.time(),
            'type': integration_type,
            'success': success,
            'error': error
        }
        self.integration_history.append(record)
        
        # 履歴サイズ制限
        if len(self.integration_history) > 1000:
            self.integration_history = self.integration_history[-500:]
    
    def get_integration_stats(self) -> Dict[str, Any]:
        """連携統計取得"""
        if not self.integration_history:
            return {}
        
        total = len(self.integration_history)
        successful = sum(1 for r in self.integration_history if r['success'])
        
        # タイプ別統計
        type_stats = {}
        for record in self.integration_history:
            integration_type = record['type']
            if integration_type not in type_stats:
                type_stats[integration_type] = {'total': 0, 'success': 0}
            
            type_stats[integration_type]['total'] += 1
            if record['success']:
                type_stats[integration_type]['success'] += 1
        
        return {
            'total_integrations': total,
            'success_rate': successful / total if total > 0 else 0,
            'by_type': type_stats,
            'enabled_connectors': list(self.connectors.keys())
        }
```

この章では、YouTubeナレッジシステムの拡張性とカスタマイズ機能について詳しく解説しました。プラグインアーキテクチャによる動的機能追加、フックシステムによるイベント駆動拡張、カスタム分析器の作成、外部API連携まで、柔軟で拡張可能なシステム設計の実践技術を習得できました。次章では、学習ロードマップと今後の発展について総括します。
