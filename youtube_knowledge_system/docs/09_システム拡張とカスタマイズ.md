# ç¬¬9ç« : ã‚·ã‚¹ãƒ†ãƒ æ‹¡å¼µã¨ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚º

## **ç« ã®æ¦‚è¦**

ã“ã®ç« ã§ã¯ã€YouTubeãƒŠãƒ¬ãƒƒã‚¸ã‚·ã‚¹ãƒ†ãƒ ã®æ‹¡å¼µæ€§ã¨ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºæ©Ÿèƒ½ã«ã¤ã„ã¦è©³ã—ãè§£èª¬ã—ã¾ã™ã€‚ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ã€ãƒ•ãƒƒã‚¯ã‚·ã‚¹ãƒ†ãƒ ã€ã‚«ã‚¹ã‚¿ãƒ åˆ†æå™¨ã€å¤–éƒ¨APIé€£æºã€æ‹¡å¼µãƒã‚¤ãƒ³ãƒˆã®è¨­è¨ˆã¾ã§ã€æŸ”è»Ÿã§æ‹¡å¼µå¯èƒ½ãªã‚·ã‚¹ãƒ†ãƒ è¨­è¨ˆæŠ€è¡“ã‚’ä½“ç³»çš„ã«å­¦ã³ã¾ã™ã€‚

**å¯¾è±¡æŠ€è¡“**: ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã‚·ã‚¹ãƒ†ãƒ ã€ãƒ•ãƒƒã‚¯ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ã€APIæ‹¡å¼µã€ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«è¨­è¨ˆ  
**ä¸»è¦ãƒ‘ã‚¿ãƒ¼ãƒ³**: Strategy, Observer, Factory, Extension Point ãƒ‘ã‚¿ãƒ¼ãƒ³

---

## **ğŸ”Œ ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ã®è¨­è¨ˆ**

### **ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã‚·ã‚¹ãƒ†ãƒ ã¨ã¯ï¼ˆåˆå¿ƒè€…å‘ã‘è§£èª¬ï¼‰**

#### **ğŸ—ï¸ ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ã®åŸºæœ¬æ¦‚å¿µ**

**ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã‚·ã‚¹ãƒ†ãƒ ã®ä»•çµ„ã¿**

ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ã¯ã€**ã‚³ã‚¢ã‚·ã‚¹ãƒ†ãƒ ã‚’å¤‰æ›´ã›ãšã«æ©Ÿèƒ½ã‚’è¿½åŠ ãƒ»æ‹¡å¼µã™ã‚‹è¨­è¨ˆãƒ‘ã‚¿ãƒ¼ãƒ³**ã§ã™ã€‚ã‚¹ãƒãƒ¼ãƒˆãƒ•ã‚©ãƒ³ã®ã‚¢ãƒ—ãƒªã‚¹ãƒˆã‚¢ã«ä¾‹ãˆã‚‹ã¨ï¼š

```python
# ã‚³ã‚¢ã‚·ã‚¹ãƒ†ãƒ ï¼ˆã‚¹ãƒãƒ¼ãƒˆãƒ•ã‚©ãƒ³ã®OSï¼‰
class YouTubeKnowledgeCore:
    def __init__(self):
        self.analyzers = []        # åˆ†æãƒ—ãƒ©ã‚°ã‚¤ãƒ³
        self.collectors = []       # åé›†ãƒ—ãƒ©ã‚°ã‚¤ãƒ³
        self.exporters = []        # ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆãƒ—ãƒ©ã‚°ã‚¤ãƒ³
        self.hooks = {}           # ãƒ•ãƒƒã‚¯ã‚·ã‚¹ãƒ†ãƒ 
    
    def register_plugin(self, plugin):
        """ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ç™»éŒ²ï¼ˆã‚¢ãƒ—ãƒªã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ï¼‰"""
        plugin.initialize(self)

# ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ï¼ˆã‚¢ãƒ—ãƒªï¼‰
class SentimentAnalyzerPlugin:
    def initialize(self, core):
        """ã‚³ã‚¢ã‚·ã‚¹ãƒ†ãƒ ã«æ©Ÿèƒ½è¿½åŠ """
        core.analyzers.append(self)
        core.hooks.register('video_analyzed', self.on_video_analyzed)
```

**å¾“æ¥ã®ãƒ¢ãƒãƒªã‚·ãƒƒã‚¯ vs ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£**

```python
# âŒ ãƒ¢ãƒãƒªã‚·ãƒƒã‚¯ï¼ˆä¸€ä½“å‹ï¼‰ã®å•é¡Œ
class MonolithicAnalyzer:
    def analyze(self, video):
        # å…¨æ©Ÿèƒ½ãŒä¸€ç®‡æ‰€ã«é›†ä¸­
        sentiment = self.analyze_sentiment(video)      # æ„Ÿæƒ…åˆ†æ
        topics = self.extract_topics(video)           # ãƒˆãƒ”ãƒƒã‚¯æŠ½å‡º
        keywords = self.extract_keywords(video)       # ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰æŠ½å‡º
        # â†’ æ–°æ©Ÿèƒ½è¿½åŠ æ™‚ã«ã‚³ã‚¢ä¿®æ­£ãŒå¿…è¦

# âœ… ãƒ—ãƒ©ã‚°ã‚¤ãƒ³å‹ã®åˆ©ç‚¹
class PluginBasedAnalyzer:
    def __init__(self):
        self.plugins = []
    
    def analyze(self, video):
        results = {}
        for plugin in self.plugins:
            if plugin.can_analyze(video):
                results[plugin.name] = plugin.analyze(video)
        return results
        # â†’ ãƒ—ãƒ©ã‚°ã‚¤ãƒ³è¿½åŠ ã§ã‚³ã‚¢å¤‰æ›´ä¸è¦
```

#### **ğŸ¯ æ‹¡å¼µãƒã‚¤ãƒ³ãƒˆï¼ˆExtension Pointsï¼‰ã®è¨­è¨ˆ**

```python
class ExtensionPoint:
    """æ‹¡å¼µãƒã‚¤ãƒ³ãƒˆã®åŸºåº•ã‚¯ãƒ©ã‚¹"""
    
    def __init__(self, name: str, description: str):
        self.name = name
        self.description = description
        self.extensions = []
    
    def register(self, extension):
        """æ‹¡å¼µã®ç™»éŒ²"""
        if self.validate_extension(extension):
            self.extensions.append(extension)
            print(f"æ‹¡å¼µç™»éŒ²: {extension.__class__.__name__} â†’ {self.name}")
        else:
            raise ValueError(f"ç„¡åŠ¹ãªæ‹¡å¼µ: {extension}")
    
    def validate_extension(self, extension) -> bool:
        """æ‹¡å¼µã®å¦¥å½“æ€§ãƒã‚§ãƒƒã‚¯"""
        # ã‚µãƒ–ã‚¯ãƒ©ã‚¹ã§å®Ÿè£…
        raise NotImplementedError
    
    def execute_all(self, *args, **kwargs):
        """å…¨æ‹¡å¼µã®å®Ÿè¡Œ"""
        results = []
        for extension in self.extensions:
            try:
                result = extension.execute(*args, **kwargs)
                results.append(result)
            except Exception as e:
                print(f"æ‹¡å¼µå®Ÿè¡Œã‚¨ãƒ©ãƒ¼ {extension.__class__.__name__}: {e}")
        return results

class AnalyzerExtensionPoint(ExtensionPoint):
    """åˆ†æå™¨æ‹¡å¼µãƒã‚¤ãƒ³ãƒˆ"""
    
    def __init__(self):
        super().__init__(
            "video_analyzer",
            "YouTubeå‹•ç”»ã®åˆ†ææ©Ÿèƒ½ã‚’æ‹¡å¼µ"
        )
    
    def validate_extension(self, extension) -> bool:
        """åˆ†æå™¨ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã®æ¤œè¨¼"""
        required_methods = ['analyze', 'get_name', 'can_handle']
        return all(hasattr(extension, method) for method in required_methods)

class CollectorExtensionPoint(ExtensionPoint):
    """ãƒ‡ãƒ¼ã‚¿åé›†æ‹¡å¼µãƒã‚¤ãƒ³ãƒˆ"""
    
    def __init__(self):
        super().__init__(
            "data_collector", 
            "ãƒ‡ãƒ¼ã‚¿åé›†æ©Ÿèƒ½ã‚’æ‹¡å¼µ"
        )
    
    def validate_extension(self, extension) -> bool:
        required_methods = ['collect', 'get_source_name', 'get_data_types']
        return all(hasattr(extension, method) for method in required_methods)
```

### **ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ç™ºè¦‹ãƒ»èª­ã¿è¾¼ã¿ã‚·ã‚¹ãƒ†ãƒ **

#### **ğŸ“¦ å‹•çš„ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ç™ºè¦‹**

```python
import importlib
import pkgutil
from pathlib import Path
from typing import List, Type, Dict, Any
import json

class PluginManager:
    """ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ç®¡ç†ã‚·ã‚¹ãƒ†ãƒ """
    
    def __init__(self, plugin_directories: List[Path] = None):
        self.plugin_directories = plugin_directories or [
            Path(__file__).parent / "plugins",
            Path.home() / ".youtube_knowledge" / "plugins"
        ]
        self.extension_points = {}
        self.loaded_plugins = {}
        self.plugin_configs = {}
        
        self.setup_extension_points()
    
    def setup_extension_points(self):
        """æ¨™æº–æ‹¡å¼µãƒã‚¤ãƒ³ãƒˆã®è¨­å®š"""
        self.extension_points = {
            'analyzers': AnalyzerExtensionPoint(),
            'collectors': CollectorExtensionPoint(),
            'exporters': ExporterExtensionPoint(),
            'gui_widgets': GUIWidgetExtensionPoint()
        }
    
    def discover_plugins(self) -> Dict[str, Dict[str, Any]]:
        """ãƒ—ãƒ©ã‚°ã‚¤ãƒ³è‡ªå‹•ç™ºè¦‹"""
        discovered = {}
        
        for plugin_dir in self.plugin_directories:
            if not plugin_dir.exists():
                continue
            
            print(f"ğŸ” ãƒ—ãƒ©ã‚°ã‚¤ãƒ³æ¤œç´¢: {plugin_dir}")
            
            # 1. ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªãƒ™ãƒ¼ã‚¹ç™ºè¦‹
            for item in plugin_dir.iterdir():
                if item.is_dir() and (item / "__init__.py").exists():
                    plugin_info = self._load_plugin_info(item)
                    if plugin_info:
                        discovered[item.name] = plugin_info
                
                # 2. å˜ä¸€ãƒ•ã‚¡ã‚¤ãƒ«ãƒ—ãƒ©ã‚°ã‚¤ãƒ³
                elif item.suffix == ".py" and not item.stem.startswith("__"):
                    plugin_info = self._load_file_plugin_info(item)
                    if plugin_info:
                        discovered[item.stem] = plugin_info
        
        return discovered
    
    def _load_plugin_info(self, plugin_path: Path) -> Dict[str, Any]:
        """ãƒ—ãƒ©ã‚°ã‚¤ãƒ³æƒ…å ±èª­ã¿è¾¼ã¿"""
        try:
            # plugin.json ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿èª­ã¿è¾¼ã¿
            metadata_file = plugin_path / "plugin.json"
            if metadata_file.exists():
                with open(metadata_file, 'r', encoding='utf-8') as f:
                    metadata = json.load(f)
            else:
                metadata = self._generate_default_metadata(plugin_path)
            
            return {
                'path': plugin_path,
                'metadata': metadata,
                'type': 'directory'
            }
            
        except Exception as e:
            print(f"ãƒ—ãƒ©ã‚°ã‚¤ãƒ³æƒ…å ±èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼ {plugin_path}: {e}")
            return None
    
    def _generate_default_metadata(self, plugin_path: Path) -> Dict[str, Any]:
        """ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ç”Ÿæˆ"""
        return {
            'name': plugin_path.name,
            'version': '1.0.0',
            'description': f'ãƒ—ãƒ©ã‚°ã‚¤ãƒ³: {plugin_path.name}',
            'author': 'Unknown',
            'entry_point': 'main.py',
            'extension_points': ['analyzers'],
            'dependencies': [],
            'enabled': True
        }
    
    def load_plugin(self, plugin_name: str, plugin_info: Dict[str, Any]) -> bool:
        """ãƒ—ãƒ©ã‚°ã‚¤ãƒ³èª­ã¿è¾¼ã¿"""
        try:
            print(f"ğŸ“¦ ãƒ—ãƒ©ã‚°ã‚¤ãƒ³èª­ã¿è¾¼ã¿: {plugin_name}")
            
            plugin_path = plugin_info['path']
            metadata = plugin_info['metadata']
            
            # ä¾å­˜é–¢ä¿‚ãƒã‚§ãƒƒã‚¯
            if not self._check_dependencies(metadata.get('dependencies', [])):
                print(f"âŒ ä¾å­˜é–¢ä¿‚ä¸è¶³: {plugin_name}")
                return False
            
            # Python ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«èª­ã¿è¾¼ã¿
            spec = importlib.util.spec_from_file_location(
                plugin_name,
                plugin_path / metadata.get('entry_point', 'main.py')
            )
            
            if spec and spec.loader:
                module = importlib.util.module_from_spec(spec)
                spec.loader.exec_module(module)
                
                # ãƒ—ãƒ©ã‚°ã‚¤ãƒ³åˆæœŸåŒ–
                if hasattr(module, 'initialize_plugin'):
                    plugin_instance = module.initialize_plugin(self)
                    self.loaded_plugins[plugin_name] = {
                        'instance': plugin_instance,
                        'module': module,
                        'metadata': metadata
                    }
                    
                    print(f"âœ… ãƒ—ãƒ©ã‚°ã‚¤ãƒ³èª­ã¿è¾¼ã¿æˆåŠŸ: {plugin_name}")
                    return True
                else:
                    print(f"âŒ initialize_plugin é–¢æ•°ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“: {plugin_name}")
            
        except Exception as e:
            print(f"âŒ ãƒ—ãƒ©ã‚°ã‚¤ãƒ³èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼ {plugin_name}: {e}")
        
        return False
    
    def _check_dependencies(self, dependencies: List[str]) -> bool:
        """ä¾å­˜é–¢ä¿‚ãƒã‚§ãƒƒã‚¯"""
        for dependency in dependencies:
            try:
                importlib.import_module(dependency)
            except ImportError:
                print(f"âš ï¸  ä¾å­˜é–¢ä¿‚ä¸è¶³: {dependency}")
                return False
        return True
    
    def load_all_plugins(self):
        """å…¨ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã®èª­ã¿è¾¼ã¿"""
        discovered = self.discover_plugins()
        
        loaded_count = 0
        for plugin_name, plugin_info in discovered.items():
            metadata = plugin_info['metadata']
            
            if metadata.get('enabled', True):
                if self.load_plugin(plugin_name, plugin_info):
                    loaded_count += 1
            else:
                print(f"â¸ï¸  ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ç„¡åŠ¹: {plugin_name}")
        
        print(f"ğŸ“Š ãƒ—ãƒ©ã‚°ã‚¤ãƒ³èª­ã¿è¾¼ã¿å®Œäº†: {loaded_count}/{len(discovered)}")
    
    def get_extension_point(self, name: str) -> ExtensionPoint:
        """æ‹¡å¼µãƒã‚¤ãƒ³ãƒˆå–å¾—"""
        return self.extension_points.get(name)
    
    def register_extension(self, extension_point_name: str, extension):
        """æ‹¡å¼µç™»éŒ²"""
        ext_point = self.get_extension_point(extension_point_name)
        if ext_point:
            ext_point.register(extension)
        else:
            raise ValueError(f"æœªçŸ¥ã®æ‹¡å¼µãƒã‚¤ãƒ³ãƒˆ: {extension_point_name}")
```

**åˆå¿ƒè€…å‘ã‘: importlib ã«ã‚ˆã‚‹å‹•çš„ã‚¤ãƒ³ãƒãƒ¼ãƒˆ**

```python
import importlib.util

# é™çš„ã‚¤ãƒ³ãƒãƒ¼ãƒˆï¼ˆé€šå¸¸ã®æ–¹æ³•ï¼‰
import my_module  # my_module.py ãŒå¿…è¦

# å‹•çš„ã‚¤ãƒ³ãƒãƒ¼ãƒˆï¼ˆãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã‚·ã‚¹ãƒ†ãƒ ç”¨ï¼‰
def load_module_from_path(module_name: str, file_path: str):
    """ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹ã‹ã‚‰ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’èª­ã¿è¾¼ã¿"""
    spec = importlib.util.spec_from_file_location(module_name, file_path)
    #                    â†‘ ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«å        â†‘ ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹
    
    if spec and spec.loader:
        module = importlib.util.module_from_spec(spec)
        spec.loader.exec_module(module)  # å®Ÿéš›ã«ã‚³ãƒ¼ãƒ‰ã‚’å®Ÿè¡Œ
        return module
    return None

# ä½¿ç”¨ä¾‹
plugin_module = load_module_from_path("sentiment_analyzer", "/plugins/sentiment_analyzer.py")
if plugin_module and hasattr(plugin_module, 'SentimentAnalyzer'):
    analyzer = plugin_module.SentimentAnalyzer()
```

---

## **ğŸª ãƒ•ãƒƒã‚¯ã‚·ã‚¹ãƒ†ãƒ ã®å®Ÿè£…**

### **ã‚¤ãƒ™ãƒ³ãƒˆãƒ‰ãƒªãƒ–ãƒ³ãƒ•ãƒƒã‚¯ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£**

#### **ğŸ“¢ ãƒ•ãƒƒã‚¯ç®¡ç†ã‚·ã‚¹ãƒ†ãƒ **

```python
from typing import Callable, List, Any, Dict
from dataclasses import dataclass
from enum import Enum
import asyncio
import inspect

class HookPriority(Enum):
    """ãƒ•ãƒƒã‚¯å„ªå…ˆåº¦"""
    HIGHEST = 1
    HIGH = 2
    NORMAL = 3
    LOW = 4
    LOWEST = 5

@dataclass
class HookRegistration:
    """ãƒ•ãƒƒã‚¯ç™»éŒ²æƒ…å ±"""
    callback: Callable
    priority: HookPriority
    once: bool = False  # ä¸€åº¦ã ã‘å®Ÿè¡Œ
    async_callback: bool = False
    conditions: Dict[str, Any] = None

class HookManager:
    """ãƒ•ãƒƒã‚¯ã‚·ã‚¹ãƒ†ãƒ ç®¡ç†"""
    
    def __init__(self):
        self.hooks: Dict[str, List[HookRegistration]] = {}
        self.hook_history: List[Dict[str, Any]] = []
        self.enabled = True
    
    def register(self, 
                event_name: str, 
                callback: Callable, 
                priority: HookPriority = HookPriority.NORMAL,
                once: bool = False,
                conditions: Dict[str, Any] = None):
        """ãƒ•ãƒƒã‚¯ç™»éŒ²"""
        
        # éåŒæœŸé–¢æ•°ãƒã‚§ãƒƒã‚¯
        is_async = asyncio.iscoroutinefunction(callback)
        
        registration = HookRegistration(
            callback=callback,
            priority=priority,
            once=once,
            async_callback=is_async,
            conditions=conditions or {}
        )
        
        if event_name not in self.hooks:
            self.hooks[event_name] = []
        
        self.hooks[event_name].append(registration)
        
        # å„ªå…ˆåº¦é †ã«ã‚½ãƒ¼ãƒˆ
        self.hooks[event_name].sort(key=lambda x: x.priority.value)
        
        print(f"ğŸª ãƒ•ãƒƒã‚¯ç™»éŒ²: {event_name} â†’ {callback.__name__} (å„ªå…ˆåº¦: {priority.name})")
    
    def unregister(self, event_name: str, callback: Callable):
        """ãƒ•ãƒƒã‚¯è§£é™¤"""
        if event_name in self.hooks:
            self.hooks[event_name] = [
                reg for reg in self.hooks[event_name] 
                if reg.callback != callback
            ]
            print(f"ğŸ—‘ï¸ ãƒ•ãƒƒã‚¯è§£é™¤: {event_name} â†’ {callback.__name__}")
    
    async def trigger_async(self, event_name: str, *args, **kwargs) -> List[Any]:
        """éåŒæœŸãƒ•ãƒƒã‚¯å®Ÿè¡Œ"""
        if not self.enabled or event_name not in self.hooks:
            return []
        
        results = []
        hooks_to_remove = []
        
        for i, registration in enumerate(self.hooks[event_name]):
            try:
                # æ¡ä»¶ãƒã‚§ãƒƒã‚¯
                if not self._check_conditions(registration.conditions, kwargs):
                    continue
                
                # ãƒ•ãƒƒã‚¯å®Ÿè¡Œ
                if registration.async_callback:
                    result = await registration.callback(*args, **kwargs)
                else:
                    result = registration.callback(*args, **kwargs)
                
                results.append(result)
                
                # å±¥æ­´è¨˜éŒ²
                self._record_hook_execution(event_name, registration, args, kwargs, result)
                
                # ä¸€å›é™ã‚Šãƒ•ãƒƒã‚¯ã®è¨˜éŒ²
                if registration.once:
                    hooks_to_remove.append(i)
                
            except Exception as e:
                print(f"âŒ ãƒ•ãƒƒã‚¯å®Ÿè¡Œã‚¨ãƒ©ãƒ¼ {event_name}::{registration.callback.__name__}: {e}")
                self._record_hook_error(event_name, registration, e)
        
        # ä¸€å›é™ã‚Šãƒ•ãƒƒã‚¯ã‚’å‰Šé™¤
        for i in reversed(hooks_to_remove):
            self.hooks[event_name].pop(i)
        
        return results
    
    def trigger(self, event_name: str, *args, **kwargs) -> List[Any]:
        """åŒæœŸãƒ•ãƒƒã‚¯å®Ÿè¡Œ"""
        if not self.enabled or event_name not in self.hooks:
            return []
        
        results = []
        hooks_to_remove = []
        
        for i, registration in enumerate(self.hooks[event_name]):
            try:
                # éåŒæœŸãƒ•ãƒƒã‚¯ã¯åŒæœŸå®Ÿè¡Œã§ã‚¹ã‚­ãƒƒãƒ—
                if registration.async_callback:
                    print(f"âš ï¸  éåŒæœŸãƒ•ãƒƒã‚¯ç„¡è¦–: {registration.callback.__name__}")
                    continue
                
                # æ¡ä»¶ãƒã‚§ãƒƒã‚¯
                if not self._check_conditions(registration.conditions, kwargs):
                    continue
                
                result = registration.callback(*args, **kwargs)
                results.append(result)
                
                self._record_hook_execution(event_name, registration, args, kwargs, result)
                
                if registration.once:
                    hooks_to_remove.append(i)
                
            except Exception as e:
                print(f"âŒ ãƒ•ãƒƒã‚¯å®Ÿè¡Œã‚¨ãƒ©ãƒ¼ {event_name}::{registration.callback.__name__}: {e}")
                self._record_hook_error(event_name, registration, e)
        
        for i in reversed(hooks_to_remove):
            self.hooks[event_name].pop(i)
        
        return results
    
    def _check_conditions(self, conditions: Dict[str, Any], kwargs: Dict[str, Any]) -> bool:
        """æ¡ä»¶ãƒã‚§ãƒƒã‚¯"""
        if not conditions:
            return True
        
        for key, expected_value in conditions.items():
            if key not in kwargs or kwargs[key] != expected_value:
                return False
        return True
    
    def _record_hook_execution(self, event_name: str, registration: HookRegistration, 
                             args: tuple, kwargs: Dict[str, Any], result: Any):
        """ãƒ•ãƒƒã‚¯å®Ÿè¡Œå±¥æ­´è¨˜éŒ²"""
        from datetime import datetime
        
        self.hook_history.append({
            'timestamp': datetime.now().isoformat(),
            'event': event_name,
            'callback': registration.callback.__name__,
            'priority': registration.priority.name,
            'success': True,
            'result_type': type(result).__name__ if result is not None else None
        })
    
    def _record_hook_error(self, event_name: str, registration: HookRegistration, error: Exception):
        """ãƒ•ãƒƒã‚¯ã‚¨ãƒ©ãƒ¼å±¥æ­´è¨˜éŒ²"""
        from datetime import datetime
        
        self.hook_history.append({
            'timestamp': datetime.now().isoformat(),
            'event': event_name,
            'callback': registration.callback.__name__,
            'priority': registration.priority.name,
            'success': False,
            'error': str(error),
            'error_type': type(error).__name__
        })
    
    def get_registered_hooks(self) -> Dict[str, List[str]]:
        """ç™»éŒ²æ¸ˆã¿ãƒ•ãƒƒã‚¯ä¸€è¦§å–å¾—"""
        return {
            event: [reg.callback.__name__ for reg in registrations]
            for event, registrations in self.hooks.items()
        }
    
    def clear_hooks(self, event_name: str = None):
        """ãƒ•ãƒƒã‚¯ã‚¯ãƒªã‚¢"""
        if event_name:
            if event_name in self.hooks:
                del self.hooks[event_name]
                print(f"ğŸ—‘ï¸ ãƒ•ãƒƒã‚¯ã‚¯ãƒªã‚¢: {event_name}")
        else:
            self.hooks.clear()
            print("ğŸ—‘ï¸ å…¨ãƒ•ãƒƒã‚¯ã‚¯ãƒªã‚¢")
```

#### **ğŸ¯ ã‚³ã‚¢ã‚·ã‚¹ãƒ†ãƒ çµ±åˆ**

```python
class ExtensibleYouTubeSystem:
    """æ‹¡å¼µå¯èƒ½ãªYouTubeãƒŠãƒ¬ãƒƒã‚¸ã‚·ã‚¹ãƒ†ãƒ """
    
    def __init__(self):
        self.hook_manager = HookManager()
        self.plugin_manager = PluginManager()
        
        # æ¨™æº–ãƒ•ãƒƒã‚¯ãƒã‚¤ãƒ³ãƒˆã®å®šç¾©
        self.setup_standard_hooks()
        
        # ãƒ—ãƒ©ã‚°ã‚¤ãƒ³èª­ã¿è¾¼ã¿
        self.plugin_manager.load_all_plugins()
    
    def setup_standard_hooks(self):
        """æ¨™æº–ãƒ•ãƒƒã‚¯ãƒã‚¤ãƒ³ãƒˆå®šç¾©"""
        self.hook_points = {
            # ãƒ‡ãƒ¼ã‚¿åé›†ãƒ•ãƒƒã‚¯
            'before_collect_videos': "å‹•ç”»åé›†é–‹å§‹å‰",
            'after_collect_videos': "å‹•ç”»åé›†å®Œäº†å¾Œ", 
            'video_collected': "å€‹åˆ¥å‹•ç”»åé›†æ™‚",
            
            # åˆ†æãƒ•ãƒƒã‚¯
            'before_analyze_video': "å‹•ç”»åˆ†æé–‹å§‹å‰",
            'after_analyze_video': "å‹•ç”»åˆ†æå®Œäº†å¾Œ",
            'analysis_failed': "åˆ†æå¤±æ•—æ™‚",
            
            # ãƒ‡ãƒ¼ã‚¿æ“ä½œãƒ•ãƒƒã‚¯
            'before_save_video': "å‹•ç”»ä¿å­˜å‰",
            'after_save_video': "å‹•ç”»ä¿å­˜å¾Œ", 
            'video_deleted': "å‹•ç”»å‰Šé™¤æ™‚",
            
            # GUI ãƒ•ãƒƒã‚¯
            'gui_startup': "GUIèµ·å‹•æ™‚",
            'video_selected': "å‹•ç”»é¸æŠæ™‚",
            'menu_action': "ãƒ¡ãƒ‹ãƒ¥ãƒ¼æ“ä½œæ™‚",
            
            # ã‚·ã‚¹ãƒ†ãƒ ãƒ•ãƒƒã‚¯
            'system_startup': "ã‚·ã‚¹ãƒ†ãƒ èµ·å‹•æ™‚",
            'system_shutdown': "ã‚·ã‚¹ãƒ†ãƒ çµ‚äº†æ™‚",
            'error_occurred': "ã‚¨ãƒ©ãƒ¼ç™ºç”Ÿæ™‚"
        }
        
        print(f"ğŸ“‹ æ¨™æº–ãƒ•ãƒƒã‚¯ãƒã‚¤ãƒ³ãƒˆå®šç¾©: {len(self.hook_points)}å€‹")
    
    def collect_videos_with_hooks(self, playlist_id: str, max_videos: int = None):
        """ãƒ•ãƒƒã‚¯ä»˜ãå‹•ç”»åé›†"""
        
        # åé›†é–‹å§‹å‰ãƒ•ãƒƒã‚¯
        hook_results = self.hook_manager.trigger(
            'before_collect_videos',
            playlist_id=playlist_id,
            max_videos=max_videos
        )
        
        # ãƒ•ãƒƒã‚¯çµæœã«ã‚ˆã‚‹å‹•ä½œå¤‰æ›´
        modified_params = self._process_hook_results(hook_results, {
            'playlist_id': playlist_id,
            'max_videos': max_videos
        })
        
        try:
            # å®Ÿéš›ã®åé›†å‡¦ç†
            collected_videos = self._perform_collection(
                modified_params['playlist_id'],
                modified_params['max_videos']
            )
            
            # å€‹åˆ¥å‹•ç”»ãƒ•ãƒƒã‚¯
            for video in collected_videos:
                self.hook_manager.trigger(
                    'video_collected',
                    video=video,
                    playlist_id=playlist_id
                )
            
            # åé›†å®Œäº†å¾Œãƒ•ãƒƒã‚¯
            self.hook_manager.trigger(
                'after_collect_videos',
                videos=collected_videos,
                success=True,
                count=len(collected_videos)
            )
            
            return collected_videos
            
        except Exception as e:
            # ã‚¨ãƒ©ãƒ¼ãƒ•ãƒƒã‚¯
            self.hook_manager.trigger(
                'error_occurred',
                error=e,
                operation='collect_videos',
                context={'playlist_id': playlist_id}
            )
            raise
    
    def analyze_video_with_hooks(self, video, analyzer_name: str = None):
        """ãƒ•ãƒƒã‚¯ä»˜ãå‹•ç”»åˆ†æ"""
        
        # åˆ†æé–‹å§‹å‰ãƒ•ãƒƒã‚¯
        self.hook_manager.trigger(
            'before_analyze_video',
            video=video,
            analyzer=analyzer_name
        )
        
        try:
            # åˆ†æå®Ÿè¡Œ
            analysis_result = self._perform_analysis(video, analyzer_name)
            
            # åˆ†æå®Œäº†å¾Œãƒ•ãƒƒã‚¯
            self.hook_manager.trigger(
                'after_analyze_video',
                video=video,
                result=analysis_result,
                success=True,
                analyzer=analyzer_name
            )
            
            return analysis_result
            
        except Exception as e:
            # åˆ†æå¤±æ•—ãƒ•ãƒƒã‚¯
            self.hook_manager.trigger(
                'analysis_failed',
                video=video,
                error=e,
                analyzer=analyzer_name
            )
            raise
    
    def _process_hook_results(self, hook_results: List[Any], original_params: Dict) -> Dict:
        """ãƒ•ãƒƒã‚¯çµæœã«ã‚ˆã‚‹ ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿å¤‰æ›´å‡¦ç†"""
        modified_params = original_params.copy()
        
        for result in hook_results:
            if isinstance(result, dict) and 'modify_params' in result:
                modifications = result['modify_params']
                modified_params.update(modifications)
                print(f"ğŸ”§ ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿å¤‰æ›´: {modifications}")
        
        return modified_params
```

**ãƒ•ãƒƒã‚¯ä½¿ç”¨ä¾‹: ã‚«ã‚¹ã‚¿ãƒ åˆ†æçµæœã®å¾Œå‡¦ç†**

```python
# ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã§ã®ãƒ•ãƒƒã‚¯ç™»éŒ²ä¾‹
def initialize_plugin(system):
    """ãƒ—ãƒ©ã‚°ã‚¤ãƒ³åˆæœŸåŒ–"""
    
    # åˆ†æå®Œäº†å¾Œã«ã‚«ã‚¹ã‚¿ãƒ å‡¦ç†ã‚’è¿½åŠ 
    system.hook_manager.register(
        'after_analyze_video',
        enhance_analysis_result,
        priority=HookPriority.HIGH
    )
    
    # ã‚¨ãƒ©ãƒ¼ç™ºç”Ÿæ™‚ã®é€šçŸ¥å‡¦ç†
    system.hook_manager.register(
        'error_occurred', 
        notify_error_to_external_service,
        conditions={'severity': 'critical'}
    )

def enhance_analysis_result(video, result, success, **kwargs):
    """åˆ†æçµæœã®æ‹¡å¼µå‡¦ç†"""
    if success and result:
        # ã‚«ã‚¹ã‚¿ãƒ å‡¦ç†: æ„Ÿæƒ…ã‚¹ã‚³ã‚¢è¿½åŠ 
        if 'creative_insight' in result:
            result['sentiment_score'] = calculate_sentiment_score(result['creative_insight'])
            print(f"ğŸ­ æ„Ÿæƒ…ã‚¹ã‚³ã‚¢è¿½åŠ : {result['sentiment_score']}")
        
        # çµæœã®å¤–éƒ¨APIé€ä¿¡
        send_to_analytics_service(video.metadata.id, result)
    
    return result

def notify_error_to_external_service(error, operation, context, **kwargs):
    """ã‚¨ãƒ©ãƒ¼ã®å¤–éƒ¨é€šçŸ¥"""
    error_data = {
        'operation': operation,
        'error_message': str(error),
        'context': context,
        'timestamp': datetime.now().isoformat()
    }
    
    # Slack/Discordç­‰ã¸ã®é€šçŸ¥
    send_notification(error_data)
```

---

## **ğŸ” ã‚«ã‚¹ã‚¿ãƒ åˆ†æå™¨ã®ä½œæˆ**

### **åˆ†æå™¨ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹**

#### **ğŸ“ åŸºåº•ã‚¯ãƒ©ã‚¹è¨­è¨ˆ**

```python
from abc import ABC, abstractmethod
from typing import Dict, List, Any, Optional
from dataclasses import dataclass
from enum import Enum

class AnalysisType(Enum):
    """åˆ†æã‚¿ã‚¤ãƒ—"""
    TEXT_ANALYSIS = "text_analysis"
    SENTIMENT_ANALYSIS = "sentiment_analysis" 
    TOPIC_EXTRACTION = "topic_extraction"
    KEYWORD_EXTRACTION = "keyword_extraction"
    VISUAL_ANALYSIS = "visual_analysis"
    AUDIO_ANALYSIS = "audio_analysis"
    METADATA_ANALYSIS = "metadata_analysis"

@dataclass
class AnalysisResult:
    """åˆ†æçµæœæ¨™æº–å½¢å¼"""
    analyzer_name: str
    analysis_type: AnalysisType
    confidence: float  # 0.0 - 1.0
    data: Dict[str, Any]
    metadata: Dict[str, Any]
    processing_time: float
    error: Optional[str] = None

class BaseAnalyzer(ABC):
    """åˆ†æå™¨åŸºåº•ã‚¯ãƒ©ã‚¹"""
    
    def __init__(self, name: str, version: str = "1.0.0"):
        self.name = name
        self.version = version
        self.supported_types = self.get_supported_types()
        self.config = self.get_default_config()
    
    @abstractmethod
    def get_supported_types(self) -> List[AnalysisType]:
        """ã‚µãƒãƒ¼ãƒˆã™ã‚‹åˆ†æã‚¿ã‚¤ãƒ—"""
        pass
    
    @abstractmethod 
    def analyze(self, video, analysis_type: AnalysisType = None) -> AnalysisResult:
        """åˆ†æå®Ÿè¡Œ"""
        pass
    
    @abstractmethod
    def can_handle(self, video) -> bool:
        """ã“ã®å‹•ç”»ã‚’åˆ†æå¯èƒ½ã‹ãƒã‚§ãƒƒã‚¯"""
        pass
    
    def get_default_config(self) -> Dict[str, Any]:
        """ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆè¨­å®š"""
        return {
            'enabled': True,
            'timeout': 30,
            'max_retries': 3
        }
    
    def validate_config(self, config: Dict[str, Any]) -> bool:
        """è¨­å®šã®å¦¥å½“æ€§ãƒã‚§ãƒƒã‚¯"""
        required_keys = ['enabled', 'timeout', 'max_retries']
        return all(key in config for key in required_keys)
    
    def get_info(self) -> Dict[str, Any]:
        """åˆ†æå™¨æƒ…å ±å–å¾—"""
        return {
            'name': self.name,
            'version': self.version,
            'supported_types': [t.value for t in self.supported_types],
            'config': self.config
        }

class SentimentAnalyzer(BaseAnalyzer):
    """æ„Ÿæƒ…åˆ†æå™¨ã®å®Ÿè£…ä¾‹"""
    
    def __init__(self):
        super().__init__("SentimentAnalyzer", "1.2.0")
        self.model = None
        self._initialize_model()
    
    def get_supported_types(self) -> List[AnalysisType]:
        return [AnalysisType.SENTIMENT_ANALYSIS, AnalysisType.TEXT_ANALYSIS]
    
    def _initialize_model(self):
        """åˆ†æãƒ¢ãƒ‡ãƒ«åˆæœŸåŒ–"""
        try:
            # å®Ÿéš›ã®å®Ÿè£…ã§ã¯å¤–éƒ¨ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‚’ä½¿ç”¨
            # from transformers import pipeline
            # self.model = pipeline("sentiment-analysis")
            
            # ãƒ€ãƒŸãƒ¼å®Ÿè£…
            self.model = "sentiment_model_placeholder"
            print(f"âœ… {self.name} ãƒ¢ãƒ‡ãƒ«åˆæœŸåŒ–å®Œäº†")
        except Exception as e:
            print(f"âŒ {self.name} ãƒ¢ãƒ‡ãƒ«åˆæœŸåŒ–å¤±æ•—: {e}")
    
    def can_handle(self, video) -> bool:
        """åˆ†æå¯èƒ½æ€§ãƒã‚§ãƒƒã‚¯"""
        # èª¬æ˜æ–‡ã¾ãŸã¯ã‚¿ã‚¤ãƒˆãƒ«ãŒã‚ã‚Šã€æ—¥æœ¬èªã¾ãŸã¯è‹±èª
        if not video.metadata.description and not video.metadata.title:
            return False
        
        text = (video.metadata.description or "") + " " + (video.metadata.title or "")
        return len(text.strip()) > 10  # æœ€ä½10æ–‡å­—
    
    def analyze(self, video, analysis_type: AnalysisType = None) -> AnalysisResult:
        """æ„Ÿæƒ…åˆ†æå®Ÿè¡Œ"""
        import time
        start_time = time.time()
        
        try:
            # åˆ†æå¯¾è±¡ãƒ†ã‚­ã‚¹ãƒˆæº–å‚™
            text = self._prepare_text(video)
            
            if not text:
                return AnalysisResult(
                    analyzer_name=self.name,
                    analysis_type=AnalysisType.SENTIMENT_ANALYSIS,
                    confidence=0.0,
                    data={},
                    metadata={'error': 'ãƒ†ã‚­ã‚¹ãƒˆãŒç©º'},
                    processing_time=time.time() - start_time,
                    error="åˆ†æå¯¾è±¡ãƒ†ã‚­ã‚¹ãƒˆãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“"
                )
            
            # å®Ÿéš›ã®æ„Ÿæƒ…åˆ†æï¼ˆãƒ€ãƒŸãƒ¼å®Ÿè£…ï¼‰
            sentiment_result = self._perform_sentiment_analysis(text)
            
            return AnalysisResult(
                analyzer_name=self.name,
                analysis_type=AnalysisType.SENTIMENT_ANALYSIS,
                confidence=sentiment_result['confidence'],
                data={
                    'sentiment': sentiment_result['sentiment'],
                    'scores': sentiment_result['scores'],
                    'keywords': sentiment_result.get('keywords', []),
                    'emotion_breakdown': sentiment_result.get('emotions', {})
                },
                metadata={
                    'text_length': len(text),
                    'language': sentiment_result.get('language', 'unknown'),
                    'model_version': self.version
                },
                processing_time=time.time() - start_time
            )
            
        except Exception as e:
            return AnalysisResult(
                analyzer_name=self.name,
                analysis_type=AnalysisType.SENTIMENT_ANALYSIS,
                confidence=0.0,
                data={},
                metadata={'error_details': str(e)},
                processing_time=time.time() - start_time,
                error=f"åˆ†æã‚¨ãƒ©ãƒ¼: {e}"
            )
    
    def _prepare_text(self, video) -> str:
        """åˆ†æç”¨ãƒ†ã‚­ã‚¹ãƒˆæº–å‚™"""
        texts = []
        
        if video.metadata.title:
            texts.append(f"ã‚¿ã‚¤ãƒˆãƒ«: {video.metadata.title}")
        
        if video.metadata.description:
            # é•·ã™ãã‚‹èª¬æ˜æ–‡ã¯åˆ‡ã‚Šè©°ã‚
            desc = video.metadata.description[:1000]
            texts.append(f"èª¬æ˜: {desc}")
        
        return "\n".join(texts)
    
    def _perform_sentiment_analysis(self, text: str) -> Dict[str, Any]:
        """æ„Ÿæƒ…åˆ†æå®Ÿè¡Œï¼ˆãƒ€ãƒŸãƒ¼å®Ÿè£…ï¼‰"""
        # å®Ÿéš›ã®å®Ÿè£…ã§ã¯æ©Ÿæ¢°å­¦ç¿’ãƒ¢ãƒ‡ãƒ«ã‚’ä½¿ç”¨
        import random
        
        sentiments = ['positive', 'negative', 'neutral']
        sentiment = random.choice(sentiments)
        confidence = random.uniform(0.6, 0.95)
        
        scores = {
            'positive': random.uniform(0.0, 1.0),
            'negative': random.uniform(0.0, 1.0), 
            'neutral': random.uniform(0.0, 1.0)
        }
        
        # æ­£è¦åŒ–
        total = sum(scores.values())
        scores = {k: v/total for k, v in scores.items()}
        
        return {
            'sentiment': sentiment,
            'confidence': confidence,
            'scores': scores,
            'language': 'ja',
            'keywords': ['éŸ³æ¥½', 'ã‚¯ãƒªã‚¨ã‚¤ãƒ†ã‚£ãƒ–', 'åˆ¶ä½œ'],
            'emotions': {
                'joy': random.uniform(0.0, 0.5),
                'sadness': random.uniform(0.0, 0.3),
                'excitement': random.uniform(0.0, 0.7)
            }
        }

class TopicExtractor(BaseAnalyzer):
    """ãƒˆãƒ”ãƒƒã‚¯æŠ½å‡ºå™¨ã®å®Ÿè£…ä¾‹"""
    
    def __init__(self):
        super().__init__("TopicExtractor", "1.0.0")
    
    def get_supported_types(self) -> List[AnalysisType]:
        return [AnalysisType.TOPIC_EXTRACTION, AnalysisType.KEYWORD_EXTRACTION]
    
    def can_handle(self, video) -> bool:
        return bool(video.metadata.description and len(video.metadata.description) > 50)
    
    def analyze(self, video, analysis_type: AnalysisType = None) -> AnalysisResult:
        """ãƒˆãƒ”ãƒƒã‚¯æŠ½å‡ºå®Ÿè¡Œ"""
        import time
        start_time = time.time()
        
        try:
            topics = self._extract_topics(video.metadata.description)
            keywords = self._extract_keywords(video.metadata.description)
            
            return AnalysisResult(
                analyzer_name=self.name,
                analysis_type=AnalysisType.TOPIC_EXTRACTION,
                confidence=0.8,
                data={
                    'topics': topics,
                    'keywords': keywords,
                    'categories': self._categorize_content(topics)
                },
                metadata={
                    'text_length': len(video.metadata.description),
                    'topics_count': len(topics),
                    'keywords_count': len(keywords)
                },
                processing_time=time.time() - start_time
            )
            
        except Exception as e:
            return AnalysisResult(
                analyzer_name=self.name,
                analysis_type=AnalysisType.TOPIC_EXTRACTION,
                confidence=0.0,
                data={},
                metadata={},
                processing_time=time.time() - start_time,
                error=str(e)
            )
    
    def _extract_topics(self, text: str) -> List[Dict[str, Any]]:
        """ãƒˆãƒ”ãƒƒã‚¯æŠ½å‡ºï¼ˆãƒ€ãƒŸãƒ¼å®Ÿè£…ï¼‰"""
        # å®Ÿè£…ä¾‹ï¼šTF-IDF, LDA, BERTç­‰ã‚’ä½¿ç”¨
        import random
        
        topics = [
            {'name': 'éŸ³æ¥½åˆ¶ä½œ', 'score': random.uniform(0.7, 0.9)},
            {'name': 'DAWæ“ä½œ', 'score': random.uniform(0.5, 0.8)},
            {'name': 'ãƒŸã‚­ã‚·ãƒ³ã‚°', 'score': random.uniform(0.4, 0.7)},
            {'name': 'ã‚¯ãƒªã‚¨ã‚¤ãƒ†ã‚£ãƒ–', 'score': random.uniform(0.6, 0.8)}
        ]
        
        return sorted(topics, key=lambda x: x['score'], reverse=True)[:3]
    
    def _extract_keywords(self, text: str) -> List[str]:
        """ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰æŠ½å‡ºï¼ˆãƒ€ãƒŸãƒ¼å®Ÿè£…ï¼‰"""
        # å®Ÿè£…ä¾‹ï¼šmecab, spacy, transformersç­‰ã‚’ä½¿ç”¨
        keywords = ['DTM', 'ãƒœã‚«ãƒ­', 'Cubase', 'ã‚®ã‚¿ãƒ¼', 'ã‚·ãƒ³ã‚»ã‚µã‚¤ã‚¶ãƒ¼']
        import random
        return random.sample(keywords, min(len(keywords), 5))
    
    def _categorize_content(self, topics: List[Dict[str, Any]]) -> List[str]:
        """ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‚«ãƒ†ã‚´ãƒªåŒ–"""
        categories = []
        
        for topic in topics:
            topic_name = topic['name'].lower()
            if any(keyword in topic_name for keyword in ['éŸ³æ¥½', 'ãƒŸãƒ¥ãƒ¼ã‚¸ãƒƒã‚¯', 'ã‚µã‚¦ãƒ³ãƒ‰']):
                categories.append('éŸ³æ¥½')
            elif any(keyword in topic_name for keyword in ['åˆ¶ä½œ', 'daw', 'ãƒŸã‚­ã‚·ãƒ³ã‚°']):
                categories.append('åˆ¶ä½œæŠ€è¡“')
            elif any(keyword in topic_name for keyword in ['ã‚¯ãƒªã‚¨ã‚¤ãƒ†ã‚£ãƒ–', 'å‰µä½œ']):
                categories.append('ã‚¯ãƒªã‚¨ã‚¤ãƒ†ã‚£ãƒ–')
        
        return list(set(categories))  # é‡è¤‡é™¤å»
```

### **åˆ†æå™¨çµ±åˆã‚·ã‚¹ãƒ†ãƒ **

#### **ğŸ”„ åˆ†æãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³**

```python
class AnalysisPipeline:
    """åˆ†æãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ç®¡ç†"""
    
    def __init__(self, hook_manager: HookManager):
        self.hook_manager = hook_manager
        self.analyzers: Dict[str, BaseAnalyzer] = {}
        self.pipeline_configs = {}
        self.analysis_cache = {}
    
    def register_analyzer(self, analyzer: BaseAnalyzer):
        """åˆ†æå™¨ç™»éŒ²"""
        if not isinstance(analyzer, BaseAnalyzer):
            raise ValueError("BaseAnalyzer ã‚’ç¶™æ‰¿ã—ãŸåˆ†æå™¨ãŒå¿…è¦ã§ã™")
        
        self.analyzers[analyzer.name] = analyzer
        print(f"ğŸ” åˆ†æå™¨ç™»éŒ²: {analyzer.name} (å¯¾å¿œã‚¿ã‚¤ãƒ—: {[t.value for t in analyzer.supported_types]})")
    
    def create_pipeline(self, name: str, analyzer_sequence: List[str], config: Dict[str, Any] = None):
        """åˆ†æãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ä½œæˆ"""
        # åˆ†æå™¨ã®å­˜åœ¨ç¢ºèª
        for analyzer_name in analyzer_sequence:
            if analyzer_name not in self.analyzers:
                raise ValueError(f"æœªç™»éŒ²ã®åˆ†æå™¨: {analyzer_name}")
        
        self.pipeline_configs[name] = {
            'sequence': analyzer_sequence,
            'config': config or {},
            'parallel': config.get('parallel', False) if config else False
        }
        
        print(f"ğŸ“‹ ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ä½œæˆ: {name} â†’ {analyzer_sequence}")
    
    def run_pipeline(self, pipeline_name: str, video, **kwargs) -> Dict[str, AnalysisResult]:
        """ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³å®Ÿè¡Œ"""
        if pipeline_name not in self.pipeline_configs:
            raise ValueError(f"æœªçŸ¥ã®ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³: {pipeline_name}")
        
        config = self.pipeline_configs[pipeline_name]
        sequence = config['sequence']
        parallel = config['parallel']
        
        # ã‚­ãƒ£ãƒƒã‚·ãƒ¥ãƒã‚§ãƒƒã‚¯
        cache_key = f"{pipeline_name}_{video.metadata.id}"
        if cache_key in self.analysis_cache:
            print(f"ğŸ“¦ ã‚­ãƒ£ãƒƒã‚·ãƒ¥ãƒ’ãƒƒãƒˆ: {cache_key}")
            return self.analysis_cache[cache_key]
        
        print(f"ğŸš€ ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³å®Ÿè¡Œ: {pipeline_name} ({'ä¸¦åˆ—' if parallel else 'é †æ¬¡'})")
        
        # ãƒ•ãƒƒã‚¯: ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³é–‹å§‹å‰
        self.hook_manager.trigger(
            'before_pipeline_execution',
            pipeline_name=pipeline_name,
            video=video,
            analyzers=sequence
        )
        
        try:
            if parallel:
                results = self._run_parallel_analysis(sequence, video, **kwargs)
            else:
                results = self._run_sequential_analysis(sequence, video, **kwargs)
            
            # çµæœã‚’ã‚­ãƒ£ãƒƒã‚·ãƒ¥
            self.analysis_cache[cache_key] = results
            
            # ãƒ•ãƒƒã‚¯: ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³å®Œäº†å¾Œ
            self.hook_manager.trigger(
                'after_pipeline_execution',
                pipeline_name=pipeline_name,
                video=video,
                results=results,
                success=True
            )
            
            return results
            
        except Exception as e:
            # ãƒ•ãƒƒã‚¯: ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã‚¨ãƒ©ãƒ¼
            self.hook_manager.trigger(
                'pipeline_execution_error',
                pipeline_name=pipeline_name,
                video=video,
                error=e
            )
            raise
    
    def _run_sequential_analysis(self, sequence: List[str], video, **kwargs) -> Dict[str, AnalysisResult]:
        """é †æ¬¡åˆ†æå®Ÿè¡Œ"""
        results = {}
        
        for analyzer_name in sequence:
            analyzer = self.analyzers[analyzer_name]
            
            if not analyzer.can_handle(video):
                print(f"â­ï¸  ã‚¹ã‚­ãƒƒãƒ—: {analyzer_name} (ãƒãƒ³ãƒ‰ãƒ«ä¸å¯)")
                continue
            
            print(f"ğŸ” åˆ†æå®Ÿè¡Œ: {analyzer_name}")
            
            try:
                result = analyzer.analyze(video, **kwargs)
                results[analyzer_name] = result
                
                # å‰ã®çµæœã‚’æ¬¡ã®åˆ†æå™¨ã«æ¸¡ã™ï¼ˆãƒã‚§ãƒ¼ãƒ³å‡¦ç†ï¼‰
                if 'chain_results' in kwargs:
                    kwargs['previous_results'] = results
                
            except Exception as e:
                error_result = AnalysisResult(
                    analyzer_name=analyzer_name,
                    analysis_type=analyzer.supported_types[0] if analyzer.supported_types else AnalysisType.TEXT_ANALYSIS,
                    confidence=0.0,
                    data={},
                    metadata={},
                    processing_time=0.0,
                    error=str(e)
                )
                results[analyzer_name] = error_result
                print(f"âŒ åˆ†æã‚¨ãƒ©ãƒ¼ {analyzer_name}: {e}")
        
        return results
    
    def _run_parallel_analysis(self, sequence: List[str], video, **kwargs) -> Dict[str, AnalysisResult]:
        """ä¸¦åˆ—åˆ†æå®Ÿè¡Œ"""
        import concurrent.futures
        import threading
        
        results = {}
        
        def analyze_single(analyzer_name: str) -> tuple[str, AnalysisResult]:
            analyzer = self.analyzers[analyzer_name]
            
            if not analyzer.can_handle(video):
                return analyzer_name, None
            
            try:
                result = analyzer.analyze(video, **kwargs)
                return analyzer_name, result
            except Exception as e:
                error_result = AnalysisResult(
                    analyzer_name=analyzer_name,
                    analysis_type=analyzer.supported_types[0] if analyzer.supported_types else AnalysisType.TEXT_ANALYSIS,
                    confidence=0.0,
                    data={},
                    metadata={},
                    processing_time=0.0,
                    error=str(e)
                )
                return analyzer_name, error_result
        
        # ä¸¦åˆ—å®Ÿè¡Œ
        with concurrent.futures.ThreadPoolExecutor(max_workers=3) as executor:
            future_to_analyzer = {
                executor.submit(analyze_single, analyzer_name): analyzer_name
                for analyzer_name in sequence
            }
            
            for future in concurrent.futures.as_completed(future_to_analyzer):
                analyzer_name, result = future.result()
                if result:
                    results[analyzer_name] = result
                    print(f"âœ… ä¸¦åˆ—åˆ†æå®Œäº†: {analyzer_name}")
        
        return results
    
    def get_available_analyzers(self) -> Dict[str, Dict[str, Any]]:
        """åˆ©ç”¨å¯èƒ½åˆ†æå™¨ä¸€è¦§"""
        return {
            name: analyzer.get_info()
            for name, analyzer in self.analyzers.items()
        }
    
    def clear_cache(self, video_id: str = None):
        """åˆ†æã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚¯ãƒªã‚¢"""
        if video_id:
            keys_to_remove = [key for key in self.analysis_cache.keys() if video_id in key]
            for key in keys_to_remove:
                del self.analysis_cache[key]
            print(f"ğŸ—‘ï¸ ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚¯ãƒªã‚¢: {video_id}")
        else:
            self.analysis_cache.clear()
            print("ğŸ—‘ï¸ å…¨åˆ†æã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚¯ãƒªã‚¢")
```

---

## **ğŸŒ å¤–éƒ¨APIé€£æºæ‹¡å¼µ**

### **APIé€£æºãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯**

#### **ğŸ”Œ æ±ç”¨APIã‚³ãƒã‚¯ã‚¿**

```python
import requests
import asyncio
import aiohttp
from typing import Optional, Dict, Any, List
from dataclasses import dataclass
from enum import Enum
import time
import json

class APIMethod(Enum):
    """HTTP ãƒ¡ã‚½ãƒƒãƒ‰"""
    GET = "GET"
    POST = "POST"
    PUT = "PUT"
    DELETE = "DELETE"
    PATCH = "PATCH"

@dataclass
class APIResponse:
    """API ãƒ¬ã‚¹ãƒãƒ³ã‚¹"""
    status_code: int
    data: Any
    headers: Dict[str, str]
    error: Optional[str] = None
    processing_time: float = 0.0

class ExternalAPIConnector:
    """å¤–éƒ¨APIé€£æºåŸºåº•ã‚¯ãƒ©ã‚¹"""
    
    def __init__(self, base_url: str, api_key: str = None, timeout: int = 30):
        self.base_url = base_url.rstrip('/')
        self.api_key = api_key
        self.timeout = timeout
        self.session = requests.Session()
        self.rate_limiter = RateLimiter()
        
        # ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆãƒ˜ãƒƒãƒ€ãƒ¼è¨­å®š
        self.session.headers.update({
            'User-Agent': 'YouTube-Knowledge-System/2.0',
            'Content-Type': 'application/json'
        })
        
        if api_key:
            self.session.headers['Authorization'] = f'Bearer {api_key}'
    
    def request(self, 
                method: APIMethod, 
                endpoint: str, 
                params: Dict[str, Any] = None,
                data: Dict[str, Any] = None,
                headers: Dict[str, str] = None) -> APIResponse:
        """API ãƒªã‚¯ã‚¨ã‚¹ãƒˆå®Ÿè¡Œ"""
        
        # ãƒ¬ãƒ¼ãƒˆåˆ¶é™ãƒã‚§ãƒƒã‚¯
        self.rate_limiter.wait_if_needed()
        
        url = f"{self.base_url}/{endpoint.lstrip('/')}"
        
        # ãƒªã‚¯ã‚¨ã‚¹ãƒˆãƒ˜ãƒƒãƒ€ãƒ¼æº–å‚™
        request_headers = self.session.headers.copy()
        if headers:
            request_headers.update(headers)
        
        start_time = time.time()
        
        try:
            response = self.session.request(
                method=method.value,
                url=url,
                params=params,
                json=data if data else None,
                headers=request_headers,
                timeout=self.timeout
            )
            
            processing_time = time.time() - start_time
            
            # ãƒ¬ã‚¹ãƒãƒ³ã‚¹å‡¦ç†
            try:
                response_data = response.json() if response.content else {}
            except json.JSONDecodeError:
                response_data = response.text
            
            return APIResponse(
                status_code=response.status_code,
                data=response_data,
                headers=dict(response.headers),
                processing_time=processing_time
            )
            
        except requests.exceptions.RequestException as e:
            processing_time = time.time() - start_time
            
            return APIResponse(
                status_code=0,
                data={},
                headers={},
                error=str(e),
                processing_time=processing_time
            )
    
    async def async_request(self, 
                           method: APIMethod, 
                           endpoint: str,
                           params: Dict[str, Any] = None,
                           data: Dict[str, Any] = None,
                           headers: Dict[str, str] = None) -> APIResponse:
        """éåŒæœŸAPIãƒªã‚¯ã‚¨ã‚¹ãƒˆ"""
        
        url = f"{self.base_url}/{endpoint.lstrip('/')}"
        
        request_headers = self.session.headers.copy()
        if headers:
            request_headers.update(headers)
        
        start_time = time.time()
        
        try:
            async with aiohttp.ClientSession(timeout=aiohttp.ClientTimeout(total=self.timeout)) as session:
                async with session.request(
                    method=method.value,
                    url=url,
                    params=params,
                    json=data,
                    headers=request_headers
                ) as response:
                    processing_time = time.time() - start_time
                    
                    try:
                        response_data = await response.json()
                    except:
                        response_data = await response.text()
                    
                    return APIResponse(
                        status_code=response.status,
                        data=response_data,
                        headers=dict(response.headers),
                        processing_time=processing_time
                    )
                    
        except Exception as e:
            processing_time = time.time() - start_time
            
            return APIResponse(
                status_code=0,
                data={},
                headers={},
                error=str(e),
                processing_time=processing_time
            )

class RateLimiter:
    """ãƒ¬ãƒ¼ãƒˆåˆ¶é™ç®¡ç†"""
    
    def __init__(self, requests_per_minute: int = 60):
        self.requests_per_minute = requests_per_minute
        self.request_times = []
    
    def wait_if_needed(self):
        """å¿…è¦ã«å¿œã˜ã¦å¾…æ©Ÿ"""
        now = time.time()
        
        # 1åˆ†ä»¥å†…ã®ãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’ä¿æŒ
        self.request_times = [t for t in self.request_times if now - t < 60]
        
        if len(self.request_times) >= self.requests_per_minute:
            # æœ€å¤ã®ãƒªã‚¯ã‚¨ã‚¹ãƒˆã‹ã‚‰1åˆ†çµŒã¤ã¾ã§å¾…æ©Ÿ
            sleep_time = 60 - (now - self.request_times[0])
            if sleep_time > 0:
                print(f"â±ï¸  ãƒ¬ãƒ¼ãƒˆåˆ¶é™: {sleep_time:.1f}ç§’å¾…æ©Ÿ")
                time.sleep(sleep_time)
        
        self.request_times.append(now)

# å…·ä½“çš„ãªAPIé€£æºå®Ÿè£…ä¾‹
class SlackNotifier(ExternalAPIConnector):
    """Slacké€šçŸ¥API"""
    
    def __init__(self, webhook_url: str):
        # Slack Webhook ã¯èªè¨¼ä¸è¦
        super().__init__(base_url="", api_key=None)
        self.webhook_url = webhook_url
    
    def send_message(self, text: str, channel: str = None, username: str = "YouTube-Knowledge-Bot") -> bool:
        """ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸é€ä¿¡"""
        payload = {
            'text': text,
            'username': username
        }
        
        if channel:
            payload['channel'] = channel
        
        try:
            response = requests.post(
                self.webhook_url,
                json=payload,
                timeout=self.timeout
            )
            
            return response.status_code == 200
            
        except Exception as e:
            print(f"Slacké€šçŸ¥ã‚¨ãƒ©ãƒ¼: {e}")
            return False
    
    def send_analysis_report(self, video_title: str, analysis_results: Dict[str, AnalysisResult]) -> bool:
        """åˆ†æçµæœãƒ¬ãƒãƒ¼ãƒˆé€ä¿¡"""
        
        # ãƒ¬ãƒãƒ¼ãƒˆä½œæˆ
        message_lines = [
            f"ğŸ“Š *å‹•ç”»åˆ†æå®Œäº†*",
            f"ğŸµ å‹•ç”»: {video_title}",
            ""
        ]
        
        for analyzer_name, result in analysis_results.items():
            if result.error:
                message_lines.append(f"âŒ {analyzer_name}: ã‚¨ãƒ©ãƒ¼ ({result.error})")
            else:
                confidence_emoji = "ğŸŸ¢" if result.confidence > 0.8 else "ğŸŸ¡" if result.confidence > 0.5 else "ğŸ”´"
                message_lines.append(f"{confidence_emoji} {analyzer_name}: ä¿¡é ¼åº¦ {result.confidence:.2f}")
        
        message = "\n".join(message_lines)
        return self.send_message(message)

class DiscordWebhook(ExternalAPIConnector):
    """Discord Webhook API"""
    
    def __init__(self, webhook_url: str):
        super().__init__(base_url="", api_key=None)
        self.webhook_url = webhook_url
    
    def send_embed(self, title: str, description: str, color: int = 0x00ff00, fields: List[Dict[str, Any]] = None) -> bool:
        """åŸ‹ã‚è¾¼ã¿ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸é€ä¿¡"""
        
        embed = {
            'title': title,
            'description': description,
            'color': color,
            'timestamp': time.strftime('%Y-%m-%dT%H:%M:%S.000Z', time.gmtime())
        }
        
        if fields:
            embed['fields'] = fields
        
        payload = {'embeds': [embed]}
        
        try:
            response = requests.post(
                self.webhook_url,
                json=payload,
                timeout=self.timeout
            )
            
            return response.status_code == 204  # Discord ã¯ 204 ã‚’è¿”ã™
            
        except Exception as e:
            print(f"Discordé€šçŸ¥ã‚¨ãƒ©ãƒ¼: {e}")
            return False

class GoogleSheetsAPI(ExternalAPIConnector):
    """Google Sheets API"""
    
    def __init__(self, api_key: str, spreadsheet_id: str):
        super().__init__(
            base_url="https://sheets.googleapis.com/v4/spreadsheets",
            api_key=api_key
        )
        self.spreadsheet_id = spreadsheet_id
    
    def append_row(self, sheet_name: str, values: List[Any]) -> bool:
        """è¡Œè¿½åŠ """
        endpoint = f"{self.spreadsheet_id}/values/{sheet_name}:append"
        
        data = {
            'values': [values],
            'majorDimension': 'ROWS'
        }
        
        response = self.request(
            APIMethod.POST,
            endpoint,
            params={'valueInputOption': 'RAW'},
            data=data
        )
        
        return response.status_code == 200
    
    def export_analysis_results(self, results: Dict[str, AnalysisResult]) -> bool:
        """åˆ†æçµæœã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ"""
        
        # ãƒ˜ãƒƒãƒ€ãƒ¼è¡Œï¼ˆåˆå›ã®ã¿ï¼‰
        headers = ['å‹•ç”»ID', 'åˆ†æå™¨', 'ä¿¡é ¼åº¦', 'ã‚¨ãƒ©ãƒ¼', 'å‡¦ç†æ™‚é–“', 'åˆ†ææ—¥æ™‚']
        
        # ãƒ‡ãƒ¼ã‚¿è¡Œä½œæˆ
        for analyzer_name, result in results.items():
            row_data = [
                result.metadata.get('video_id', ''),
                analyzer_name,
                result.confidence,
                result.error or '',
                result.processing_time,
                time.strftime('%Y-%m-%d %H:%M:%S')
            ]
            
            if not self.append_row('åˆ†æçµæœ', row_data):
                return False
        
        return True
```

### **APIé€£æºãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã®çµ±åˆ**

#### **ğŸ”— çµ±åˆç®¡ç†ã‚·ã‚¹ãƒ†ãƒ **

```python
class ExternalIntegrationManager:
    """å¤–éƒ¨é€£æºç®¡ç†"""
    
    def __init__(self, hook_manager: HookManager, config: Dict[str, Any] = None):
        self.hook_manager = hook_manager
        self.config = config or {}
        self.connectors: Dict[str, ExternalAPIConnector] = {}
        self.integration_history = []
        
        self.setup_integrations()
        self.register_hooks()
    
    def setup_integrations(self):
        """é€£æºã‚µãƒ¼ãƒ“ã‚¹è¨­å®š"""
        
        # Slacké€£æºè¨­å®š
        if 'slack' in self.config and self.config['slack'].get('enabled'):
            webhook_url = self.config['slack']['webhook_url']
            self.connectors['slack'] = SlackNotifier(webhook_url)
            print("âœ… Slacké€£æºè¨­å®šå®Œäº†")
        
        # Discordé€£æºè¨­å®š
        if 'discord' in self.config and self.config['discord'].get('enabled'):
            webhook_url = self.config['discord']['webhook_url']
            self.connectors['discord'] = DiscordWebhook(webhook_url)
            print("âœ… Discordé€£æºè¨­å®šå®Œäº†")
        
        # Google Sheetsé€£æºè¨­å®š
        if 'google_sheets' in self.config and self.config['google_sheets'].get('enabled'):
            api_key = self.config['google_sheets']['api_key']
            spreadsheet_id = self.config['google_sheets']['spreadsheet_id']
            self.connectors['google_sheets'] = GoogleSheetsAPI(api_key, spreadsheet_id)
            print("âœ… Google Sheetsé€£æºè¨­å®šå®Œäº†")
    
    def register_hooks(self):
        """ãƒ•ãƒƒã‚¯ç™»éŒ²"""
        
        # åˆ†æå®Œäº†æ™‚ã®é€šçŸ¥
        self.hook_manager.register(
            'after_analyze_video',
            self.on_analysis_complete,
            priority=HookPriority.LOW  # æœ€å¾Œã«å®Ÿè¡Œ
        )
        
        # ã‚¨ãƒ©ãƒ¼ç™ºç”Ÿæ™‚ã®é€šçŸ¥
        self.hook_manager.register(
            'error_occurred',
            self.on_error_occurred,
            priority=HookPriority.HIGH
        )
        
        # ã‚·ã‚¹ãƒ†ãƒ çµ±è¨ˆã®å®šæœŸé€ä¿¡
        self.hook_manager.register(
            'daily_report',
            self.send_daily_report
        )
    
    def on_analysis_complete(self, video, result, success, **kwargs):
        """åˆ†æå®Œäº†æ™‚å‡¦ç†"""
        if not success:
            return
        
        try:
            # Slacké€šçŸ¥
            if 'slack' in self.connectors:
                self.connectors['slack'].send_analysis_report(
                    video.metadata.title,
                    {'analyzer': result} if isinstance(result, AnalysisResult) else result
                )
            
            # Google Sheets ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ
            if 'google_sheets' in self.connectors:
                self.connectors['google_sheets'].export_analysis_results(
                    {'analyzer': result} if isinstance(result, AnalysisResult) else result
                )
            
            self._record_integration('analysis_notification', True)
            
        except Exception as e:
            print(f"å¤–éƒ¨é€£æºã‚¨ãƒ©ãƒ¼: {e}")
            self._record_integration('analysis_notification', False, str(e))
    
    def on_error_occurred(self, error, operation, context, **kwargs):
        """ã‚¨ãƒ©ãƒ¼ç™ºç”Ÿæ™‚å‡¦ç†"""
        
        error_level = self._determine_error_level(error, operation)
        
        if error_level in ['critical', 'high']:
            try:
                # é‡è¦ã‚¨ãƒ©ãƒ¼ã®å³åº§é€šçŸ¥
                if 'slack' in self.connectors:
                    message = f"ğŸš¨ *ã‚·ã‚¹ãƒ†ãƒ ã‚¨ãƒ©ãƒ¼ç™ºç”Ÿ*\næ“ä½œ: {operation}\nã‚¨ãƒ©ãƒ¼: {str(error)}"
                    self.connectors['slack'].send_message(message)
                
                if 'discord' in self.connectors:
                    self.connectors['discord'].send_embed(
                        title="ğŸš¨ ã‚·ã‚¹ãƒ†ãƒ ã‚¨ãƒ©ãƒ¼",
                        description=f"æ“ä½œ: {operation}\nã‚¨ãƒ©ãƒ¼: {str(error)}",
                        color=0xff0000,  # èµ¤è‰²
                        fields=[
                            {'name': 'ãƒ¬ãƒ™ãƒ«', 'value': error_level, 'inline': True},
                            {'name': 'æ™‚åˆ»', 'value': time.strftime('%Y-%m-%d %H:%M:%S'), 'inline': True}
                        ]
                    )
                
                self._record_integration('error_notification', True)
                
            except Exception as e:
                print(f"ã‚¨ãƒ©ãƒ¼é€šçŸ¥å¤±æ•—: {e}")
                self._record_integration('error_notification', False, str(e))
    
    def send_daily_report(self, **kwargs):
        """æ—¥æ¬¡ãƒ¬ãƒãƒ¼ãƒˆé€ä¿¡"""
        try:
            from storage.unified_storage import get_storage
            storage = get_storage()
            stats = storage.get_statistics()
            
            # ãƒ¬ãƒãƒ¼ãƒˆä½œæˆ
            report_text = f"""ğŸ“Š *YouTube Knowledge System æ—¥æ¬¡ãƒ¬ãƒãƒ¼ãƒˆ*

ğŸ“ˆ *çµ±è¨ˆæƒ…å ±*
â€¢ ç·å‹•ç”»æ•°: {stats['total_videos']}
â€¢ åˆ†ææ¸ˆã¿: {stats['analyzed_videos']}
â€¢ æˆåŠŸç‡: {stats['analysis_success_rate']:.1%}
â€¢ ãƒ—ãƒ¬ã‚¤ãƒªã‚¹ãƒˆæ•°: {stats['total_playlists']}

ğŸ¯ *ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹*
â€¢ ã‚¯ãƒªã‚¨ã‚¤ã‚¿ãƒ¼æ•°: {stats['total_creators']}
â€¢ ãƒ†ãƒ¼ãƒæ•°: {stats['total_themes']}
â€¢ æœ€çµ‚æ›´æ–°: {stats['last_updated']}"""
            
            # Slacké€ä¿¡
            if 'slack' in self.connectors:
                self.connectors['slack'].send_message(report_text)
            
            # Discordé€ä¿¡ï¼ˆåŸ‹ã‚è¾¼ã¿å½¢å¼ï¼‰
            if 'discord' in self.connectors:
                fields = [
                    {'name': 'ç·å‹•ç”»æ•°', 'value': str(stats['total_videos']), 'inline': True},
                    {'name': 'åˆ†ææ¸ˆã¿', 'value': str(stats['analyzed_videos']), 'inline': True},
                    {'name': 'æˆåŠŸç‡', 'value': f"{stats['analysis_success_rate']:.1%}", 'inline': True}
                ]
                
                self.connectors['discord'].send_embed(
                    title="ğŸ“Š æ—¥æ¬¡ãƒ¬ãƒãƒ¼ãƒˆ",
                    description="YouTube Knowledge System ã®çµ±è¨ˆæƒ…å ±",
                    color=0x00ff00,
                    fields=fields
                )
            
            self._record_integration('daily_report', True)
            
        except Exception as e:
            print(f"æ—¥æ¬¡ãƒ¬ãƒãƒ¼ãƒˆé€ä¿¡ã‚¨ãƒ©ãƒ¼: {e}")
            self._record_integration('daily_report', False, str(e))
    
    def _determine_error_level(self, error: Exception, operation: str) -> str:
        """ã‚¨ãƒ©ãƒ¼ãƒ¬ãƒ™ãƒ«åˆ¤å®š"""
        error_message = str(error).lower()
        
        if any(keyword in error_message for keyword in ['critical', 'fatal', 'database', 'corruption']):
            return 'critical'
        elif any(keyword in error_message for keyword in ['api', 'auth', 'permission']):
            return 'high'
        elif any(keyword in error_message for keyword in ['network', 'timeout', 'connection']):
            return 'medium'
        else:
            return 'low'
    
    def _record_integration(self, integration_type: str, success: bool, error: str = None):
        """é€£æºå±¥æ­´è¨˜éŒ²"""
        record = {
            'timestamp': time.time(),
            'type': integration_type,
            'success': success,
            'error': error
        }
        self.integration_history.append(record)
        
        # å±¥æ­´ã‚µã‚¤ã‚ºåˆ¶é™
        if len(self.integration_history) > 1000:
            self.integration_history = self.integration_history[-500:]
    
    def get_integration_stats(self) -> Dict[str, Any]:
        """é€£æºçµ±è¨ˆå–å¾—"""
        if not self.integration_history:
            return {}
        
        total = len(self.integration_history)
        successful = sum(1 for r in self.integration_history if r['success'])
        
        # ã‚¿ã‚¤ãƒ—åˆ¥çµ±è¨ˆ
        type_stats = {}
        for record in self.integration_history:
            integration_type = record['type']
            if integration_type not in type_stats:
                type_stats[integration_type] = {'total': 0, 'success': 0}
            
            type_stats[integration_type]['total'] += 1
            if record['success']:
                type_stats[integration_type]['success'] += 1
        
        return {
            'total_integrations': total,
            'success_rate': successful / total if total > 0 else 0,
            'by_type': type_stats,
            'enabled_connectors': list(self.connectors.keys())
        }
```

ã“ã®ç« ã§ã¯ã€YouTubeãƒŠãƒ¬ãƒƒã‚¸ã‚·ã‚¹ãƒ†ãƒ ã®æ‹¡å¼µæ€§ã¨ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºæ©Ÿèƒ½ã«ã¤ã„ã¦è©³ã—ãè§£èª¬ã—ã¾ã—ãŸã€‚ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ã«ã‚ˆã‚‹å‹•çš„æ©Ÿèƒ½è¿½åŠ ã€ãƒ•ãƒƒã‚¯ã‚·ã‚¹ãƒ†ãƒ ã«ã‚ˆã‚‹ã‚¤ãƒ™ãƒ³ãƒˆé§†å‹•æ‹¡å¼µã€ã‚«ã‚¹ã‚¿ãƒ åˆ†æå™¨ã®ä½œæˆã€å¤–éƒ¨APIé€£æºã¾ã§ã€æŸ”è»Ÿã§æ‹¡å¼µå¯èƒ½ãªã‚·ã‚¹ãƒ†ãƒ è¨­è¨ˆã®å®Ÿè·µæŠ€è¡“ã‚’ç¿’å¾—ã§ãã¾ã—ãŸã€‚æ¬¡ç« ã§ã¯ã€å­¦ç¿’ãƒ­ãƒ¼ãƒ‰ãƒãƒƒãƒ—ã¨ä»Šå¾Œã®ç™ºå±•ã«ã¤ã„ã¦ç·æ‹¬ã—ã¾ã™ã€‚
